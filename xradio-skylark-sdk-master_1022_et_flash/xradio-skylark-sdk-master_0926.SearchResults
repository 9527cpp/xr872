---- __CONFIG_SECURE_BOOT Matches (16 in 6 files) ----
Config.mk:__CONFIG_SECURE_BOOT ?= n
Config.mk:ifeq ($(__CONFIG_SECURE_BOOT), y)
Localconfig.mk (project\bootloader\gcc):export __CONFIG_SECURE_BOOT := n
Main.c (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Main.c (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Main.c (project\bootloader):#endif /* __CONFIG_SECURE_BOOT */
Main.c (project\bootloader):#if (defined(__CONFIG_SECURE_BOOT) && BL_SB_TEST_LOAD_BOOT_BIN)
Main.c (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Main.c (project\bootloader):#if (defined(__CONFIG_SECURE_BOOT) && BL_SB_TEST_LOAD_BOOT_BIN)
Platform_init.c (project\common\framework):#if ((defined(__CONFIG_XIP)) || (defined(__CONFIG_PSRAM)) || (defined(__CONFIG_SECURE_BOOT)))
Platform_init.c (project\common\framework):#if (defined(__CONFIG_SECURE_BOOT))
Prj_config.h (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Project.mk (project):ifeq ($(__CONFIG_SECURE_BOOT), y)
Project.mk (project):ifeq ($(__CONFIG_SECURE_BOOT), y)
Project.mk (project):ifeq ($(__CONFIG_SECURE_BOOT), y)
Project.mk (project):endif # __CONFIG_SECURE_BOOT
---- __CONFIG_CHIP_ARCH_VER Matches (200 in 59 files) ----
Board_common.c (project\common\board):#if (__CONFIG_CHIP_ARCH_VER == 2)
Board_common.c (project\common\board):#if (__CONFIG_CHIP_ARCH_VER == 1)
Board_common.c (project\common\board):#if (__CONFIG_CHIP_ARCH_VER == 1)
Buttons_low_level.c (project\common\apps\buttons):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Chip.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Chip.mk:  __CONFIG_CHIP_ARCH_VER := 2
Chip.mk:  __CONFIG_CHIP_ARCH_VER := 2
Chip.mk:CONFIG_SYMBOLS += -D__CONFIG_CHIP_ARCH_VER=$(__CONFIG_CHIP_ARCH_VER)
Chip.mk:  ifndef __CONFIG_CHIP_ARCH_VER
Cmd_adc.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_ce.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_ce.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_ce.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_clock.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_gpio.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_gpio.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_gpio.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_gpio.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_sysinfo.c (project\common\cmd):	CMD_LOG(1, "chip arch version %d\n", __CONFIG_CHIP_ARCH_VER);
Cmd_wdg.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_wdg.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Cmd_wdg.c (project\common\cmd):#if (__CONFIG_CHIP_ARCH_VER == 2)
Config.mk:ifeq ($(__CONFIG_CHIP_ARCH_VER), 1)
Drv_trng.c (src\driver\chip\crypto):#if (__CONFIG_CHIP_ARCH_VER == 2)
Drv_trng.c (src\driver\chip\crypto):#endif /*(__CONFIG_CHIP_ARCH_VER == 2) */
Drv_trng.h (src\driver\chip\crypto):#if (__CONFIG_CHIP_ARCH_VER == 2)
Drv_trng.h (src\driver\chip\crypto):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Efpg_efuse.c (src\efpg):#if (__CONFIG_CHIP_ARCH_VER == 1)
Efpg_efuse.c (src\efpg):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Efpg_i.h (src\efpg):#if (__CONFIG_CHIP_ARCH_VER == 1)
Efpg_i.h (src\efpg):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Gcc.mk:PLATFORM_RELATIVE_PATH := xradio_v$(__CONFIG_CHIP_ARCH_VER)
Hal_adc.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_adc.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_adc.h (include\driver\chip):#endif /* __CONFIG_CHIP_ARCH_VER */
Hal_adc.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_ccm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#endif /* __CONFIG_CHIP_ARCH_VER */
Hal_ccm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_ccm.h (include\driver\chip):#endif /* __CONFIG_CHIP_ARCH_VER */
Hal_clock.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_csi.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_csi_jpeg.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_csi_jpeg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_csi_jpeg.h (include\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_dcache.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_dcache.c (src\driver\chip):#endif/* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_dcache.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_dcache.h (include\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_dma.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_dmic.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_dmic.c (src\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 1) */
Hal_efuse.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_efuse.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_flashctrl.h (include\driver\chip):#define FLASHCTRL_ARCH_V2		(__CONFIG_CHIP_ARCH_VER == 2)
Hal_global.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_global.c (src\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_gpio.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_gpio.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_gpio.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_gpio.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_gpio.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_gpio.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_gpio.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_gpio.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_icache.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_icache.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_icache.h (include\driver\chip):#endif /* __CONFIG_CHIP_ARCH_VER */
Hal_mbox.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_mbox.c (src\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 1) */
Hal_prcm.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.c (src\driver\chip):#endif /*__CONFIG_CHIP_ARCH_VER */
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#endif /* __CONFIG_CHIP_ARCH_VER */
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#endif /* __CONFIG_CHIP_ARCH_VER */
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_prcm.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_psramctrl.h (include\driver\chip\psram):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_psramctrl.h (include\driver\chip\psram):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_sdhost.h (include\driver\chip\sdmmc):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_spinlock.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_spinlock.c (src\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 1) */
Hal_trng.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_trng.c (src\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_trng.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_trng.h (include\driver\chip):#endif /* (__CONFIG_CHIP_ARCH_VER == 2) */
Hal_uart.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_uart.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
Hal_uart.h (include\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Hal_wdg.h (include\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Main.c (project\example\adc):#if (__CONFIG_CHIP_ARCH_VER == 2)
Main.c (project\example\dma): *	#if (__CONFIG_CHIP_ARCH_VER == 2)
Main.c (project\example\efpg):#if (__CONFIG_CHIP_ARCH_VER == 1)
Main.c (project\example\efpg):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Net_ctrl.c (project\common\framework):  #if (__CONFIG_CHIP_ARCH_VER == 1)
Platform_init.c (project\common\framework):#if (__CONFIG_CHIP_ARCH_VER == 2)
Platform_init.c (project\common\framework):#if (__CONFIG_CHIP_ARCH_VER == 2)
Platform_init.c (project\common\framework):#if (__CONFIG_CHIP_ARCH_VER == 2)
Platform_init.c (project\common\framework):#if (__CONFIG_CHIP_ARCH_VER == 1)
Pm.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Pm.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Pm.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Pm.c (src\pm):#elif (__CONFIG_CHIP_ARCH_VER == 2)
Pm.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 2)
Pm.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Pm.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Port.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Port.c (src\pm):#if (__CONFIG_CHIP_ARCH_VER == 1)
Port.h (src\pm):#if (__CONFIG_CHIP_ARCH_VER >= 1)
Prj_config.h (project\example\fast_connect):#if (__CONFIG_CHIP_ARCH_VER == 2)
Prj_config.h (project\example\pm):#if (__CONFIG_CHIP_ARCH_VER == 2)
Prj_config.h (project\example\wlan):#if (__CONFIG_CHIP_ARCH_VER == 2)
Prj_conf_opt.h (project\common):#if (__CONFIG_CHIP_ARCH_VER == 2)
Project.mk (project):  ifeq ($(__CONFIG_CHIP_ARCH_VER), 1)
Project.mk (project):ifeq ($(__CONFIG_CHIP_ARCH_VER), 2)
Project.mk (project):ROM_SYMBOL_FILE := $(ROOT_PATH)/lib/xradio_v$(__CONFIG_CHIP_ARCH_VER)/$(ROM_SYMBOL_NAME)
_sdhost.h (src\driver\chip\sdmmc):#if (__CONFIG_CHIP_ARCH_VER == 2)
System_chip.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
System_chip.c (src\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
System_chip.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 1)
System_chip.c (src\driver\chip):#elif (__CONFIG_CHIP_ARCH_VER == 2)
System_chip.c (src\driver\chip):#if (__CONFIG_CHIP_ARCH_VER == 2)
Time.h (include\libc\sys):#if ((__CONFIG_CHIP_ARCH_VER == 1) && (!defined(__CONFIG_BOOTLOADER)))
Wlan.h (include\net\wlan):#if (__CONFIG_CHIP_ARCH_VER == 1)
Wlan.h (include\net\wlan):#if (__CONFIG_CHIP_ARCH_VER == 1)
Wrap_time.c (src\libc):#if (__CONFIG_CHIP_ARCH_VER == 2)
---- MIC_GAIN Matches (0 in 0 files) ----
---- MIC Matches (1238 in 202 files) ----
Ac107.c (src\driver\chip\codec):static void ac107_set_amic(bool enable)
Ac107.c (src\driver\chip\codec):	AC107_ALWAYS("Route(cap): main mic %s\n",enable ? "Enable" : "Disable");
Ac107.c (src\driver\chip\codec):	ac107_multi_chips_update_bits(PWR_CTRL2, 0x1<<MICBIAS2_EN | 0x1<<MICBIAS1_EN, !!enable<<MICBIAS2_EN | !!enable<<MICBIAS1_EN);
Ac107.c (src\driver\chip\codec):static void ac107_set_dmic(bool enable)
Ac107.c (src\driver\chip\codec):	AC107_ALWAYS("Route(cap): dmic %s\n",enable ? "Enable" : "Disable");
Ac107.c (src\driver\chip\codec):	/* DMIC enable/disable */
Ac107.c (src\driver\chip\codec):	ac107_multi_chips_update_bits(DMIC_EN, 0x1, !!enable);
Ac107.c (src\driver\chip\codec):		case AUDIO_IN_DEV_AMIC:
Ac107.c (src\driver\chip\codec):					AC107_ERR("Invalid Amic volume level: %d!\n",vol_set_value);
Ac107.c (src\driver\chip\codec):				AC107_ALWAYS("AMIC set volume Level-[%d]\n",vol_set_value);
Ac107.c (src\driver\chip\codec):						AC107_ALWAYS("AMIC set volume Gain-[%d]\n",vol_set_value);
Ac107.c (src\driver\chip\codec):					AC107_ERR("Invalid main mic volume gain: %d!\n",vol_set_value);
Ac107.c (src\driver\chip\codec):		case AUDIO_IN_DEV_DMIC:
Ac107.c (src\driver\chip\codec):			AC107_ERR("DMIC don't support set volume\n");
Ac107.c (src\driver\chip\codec):		case AUDIO_IN_DEV_AMIC:
Ac107.c (src\driver\chip\codec):			ac107_set_amic(enable);
Ac107.c (src\driver\chip\codec):		case AUDIO_IN_DEV_DMIC:
Ac107.c (src\driver\chip\codec):			ac107_set_dmic(enable);
Ac107.h (src\driver\chip\codec):#define DMIC_EN				0x62
Ac107.h (src\driver\chip\codec):#define MICBIAS2_EN			6
Ac107.h (src\driver\chip\codec):#define MICBIAS2_VCTRL		4
Ac107.h (src\driver\chip\codec):#define MICBIAS1_EN			2
Ac107.h (src\driver\chip\codec):#define MICBIAS1_VCTRL		0
Ac107.h (src\driver\chip\codec):/* DMIC_EN */
Ac107.h (src\driver\chip\codec):#define DIG_MIC_EN			0
Ac107.h (src\driver\chip\codec):#define DMIC_CLK_PAD_SEL	4
Ac107.h (src\driver\chip\codec):#define DMIC_DAT_PAD_SEL	0
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_ADPCM                   0x0002  /* Microsoft ADPCM Format */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_DTS                     0x0008 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_DRM                     0x0009 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_WMAVOICE9               0x000A /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_WMAVOICE10              0x000B /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_MSAUDIO1                0x0160 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_WMAUDIO2                0x0161 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_WMAUDIO3                0x0162 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_WMAUDIO_LOSSLESS        0x0163 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_WMASPDIF                0x0164 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_RAW_SPORT               0x0240 /* Aureal Semiconductor */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_MPEG_ADTS_AAC           0x1600 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_MPEG_RAW_AAC            0x1601 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_NOKIA_MPEG_ADTS_AAC     0x1608 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_NOKIA_MPEG_RAW_AAC      0x1609 /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_VODAFONE_MPEG_ADTS_AAC  0x160A /* Microsoft Corporation */
Adecoder.h (include\cedarx\cdx2.0plugin\include):#define WAVE_FORMAT_VODAFONE_MPEG_RAW_AAC   0x160B /* Microsoft Corporation */
Arch.h (include\net\lwip-2.0.3\lwip):  * Placed between end of declaration of a packed struct and trailing semicolon.\n
Atomic.c (src\util):#include "util/atomic.h"
Atomic.c (src\util):int arch_atomic_add_return(int *v, int i)
Atomic.c (src\util):int arch_atomic_sub_return(int *v, int i)
Atomic.c (src\util):int arch_atomic_and_return(int *v, int i)
Atomic.c (src\util):int arch_atomic_or_return(int *v, int i)
Atomic.c (src\util):int arch_atomic_xor_return(int *v, int i)
Atomic.c (src\util):int arch_atomic_nand_return(int *v, int i)
Atomic.c (src\util):int arch_atomic_cmpxchg(int *v, int old, int new_v)
Atomic.c (src\util):void arch_atomic_clear_mask(uint32_t *addr, uint32_t mask)
Atomic.c (src\util):void arch_atomic_set_mask(uint32_t *addr, uint32_t mask)
Atomic.c (src\util):int arch_atomic_xchg(int *v, int i)
Atomic.h (include\util):#ifndef _UTIL_ATOMIC_H_
Atomic.h (include\util):#define _UTIL_ATOMIC_H_
Atomic.h (include\util):static __inline int arch_atomic_read(volatile int *v)
Atomic.h (include\util):static __inline int arch_atomic_set(volatile int *v, int i)
Atomic.h (include\util):int arch_atomic_add_return(int *v, int i);
Atomic.h (include\util):int arch_atomic_sub_return(int *v, int i);
Atomic.h (include\util):int arch_atomic_and_return(int *v, int i);
Atomic.h (include\util):int arch_atomic_or_return(int *v, int i);
Atomic.h (include\util):int arch_atomic_xor_return(int *v, int i);
Atomic.h (include\util):int arch_atomic_nand_return(int *v, int i);
Atomic.h (include\util):static __inline int arch_atomic_inc_return(int *v)
Atomic.h (include\util):	return arch_atomic_add_return(v, 1);
Atomic.h (include\util):static __inline int arch_atomic_dec_return(int *v)
Atomic.h (include\util):	return arch_atomic_sub_return(v, 1);
Atomic.h (include\util):static __inline void arch_atomic_add(int *v, int i)
Atomic.h (include\util):	arch_atomic_add_return(v, i);
Atomic.h (include\util):static __inline void arch_atomic_sub(int *v, int i)
Atomic.h (include\util):	arch_atomic_sub_return(v, i);
Atomic.h (include\util):static __inline void arch_atomic_and(int *v, int i)
Atomic.h (include\util):	arch_atomic_and_return(v, i);
Atomic.h (include\util):static __inline void arch_atomic_or(int *v, int i)
Atomic.h (include\util):	arch_atomic_or_return(v, i);
Atomic.h (include\util):static __inline void arch_atomic_xor(int *v, int i)
Atomic.h (include\util):	arch_atomic_xor_return(v, i);
Atomic.h (include\util):static __inline void arch_atomic_nand(int *v, int i)
Atomic.h (include\util):	arch_atomic_nand_return(v, i);
Atomic.h (include\util):static __inline void arch_atomic_inc(int *v)
Atomic.h (include\util):	arch_atomic_add_return(v, 1);
Atomic.h (include\util):static __inline void arch_atomic_dec(int *v)
Atomic.h (include\util):	arch_atomic_sub_return(v, 1);
Atomic.h (include\util):int arch_atomic_xchg(int *v, int i);
Atomic.h (include\util):int arch_atomic_cmpxchg(int *v, int old, int new_v);
Atomic.h (include\util):void arch_atomic_clear_mask(uint32_t *addr, uint32_t mask);
Atomic.h (include\util):void arch_atomic_set_mask(uint32_t *addr, uint32_t mask);
Atomic.h (include\util):#endif /* _UTIL_ATOMIC_H_ */
Audio_pcm.c (src\audio\pcm):#include "driver/chip/hal_dmic.h"
Audio_record.c (project\example\audio_play_and_record):    audio_manager_handler(AUDIO_SND_CARD_DEFAULT, AUDIO_MANAGER_SET_ROUTE, AUDIO_IN_DEV_AMIC, 1);
Audio_record.c (project\example\audio_play_and_record):    audio_manager_handler(AUDIO_SND_CARD_DEFAULT, AUDIO_MANAGER_SET_ROUTE, AUDIO_IN_DEV_DMIC, 1);
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_PRIOSUB | OPT_A2OR | MDTYPE_MICROSOFT,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_ALIAS | OPT_PRIOSUB | OPT_A2OR | MDTYPE_MICROSOFT,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_PRIOSUB | OPT_A2OR | MDTYPE_MICROSOFT_V2,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_ALIAS | OPT_PRIOSUB | OPT_A2OR | MDTYPE_MICROSOFT_V2,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_A2CLRB | MDTYPE_MICROSOFT,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_ALIAS | OPT_A2CLRB | MDTYPE_MICROSOFT,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_A2CLRB | MDTYPE_MICROSOFT_V2,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):      OPT_ALIAS | OPT_A2CLRB | MDTYPE_MICROSOFT_V2,
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):     * we need the atomicity that the tdb_writelock/tdb_writeunlock
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):	case CHAP_MICROSOFT:
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):	case CHAP_MICROSOFT_V2:
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):	case CHAP_MICROSOFT:
Auth.c (src\net\lwip-2.0.3\src\netif\ppp):	case CHAP_MICROSOFT_V2:
Bn_mul.h (include\net\mbedtls-2.16.0\mbedtls): *         . PowerPC, 32-bit      . MicroBlaze
Bn_mul.h (include\net\mbedtls-2.16.0\mbedtls):#if defined(__microblaze__) || defined(microblaze)
Bn_mul.h (include\net\mbedtls-2.16.0\mbedtls):#endif /* MicroBlaze */
Bn_mul.h (include\net\mbedtls-2.2.0\mbedtls): *         . PowerPC, 32-bit      . MicroBlaze
Bn_mul.h (include\net\mbedtls-2.2.0\mbedtls):#if defined(__microblaze__) || defined(microblaze)
Bn_mul.h (include\net\mbedtls-2.2.0\mbedtls):#endif /* MicroBlaze */
Bn_mul.h (src\net\mbedtls-2.16.0\include\mbedtls): *         . PowerPC, 32-bit      . MicroBlaze
Bn_mul.h (src\net\mbedtls-2.16.0\include\mbedtls):#if defined(__microblaze__) || defined(microblaze)
Bn_mul.h (src\net\mbedtls-2.16.0\include\mbedtls):#endif /* MicroBlaze */
Board_config.c (project\common\board\xradio_audio):static const GPIO_PinMuxParam g_pinmux_dmic[] = {
Board_config.c (project\common\board\xradio_audio):	{ GPIO_PORT_A, GPIO_PIN_21, { GPIOA_P21_F3_DMIC_CLK,  GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_audio):	{ GPIO_PORT_A, GPIO_PIN_22, { GPIOA_P22_F3_DMIC_DATA, GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_audio):	case HAL_DEV_MAJOR_DMIC:
Board_config.c (project\common\board\xradio_audio):		info[0].pinmux = g_pinmux_dmic;
Board_config.c (project\common\board\xradio_audio):		info[0].count = HAL_ARRAY_SIZE(g_pinmux_dmic);
Board_config.c (project\common\board\xradio_evb):static const GPIO_PinMuxParam g_pinmux_dmic[] = {
Board_config.c (project\common\board\xradio_evb):	{ GPIO_PORT_A, GPIO_PIN_21, { GPIOA_P21_F3_DMIC_CLK,  GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_evb):	{ GPIO_PORT_A, GPIO_PIN_22, { GPIOA_P22_F3_DMIC_DATA, GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_evb):	case HAL_DEV_MAJOR_DMIC:
Board_config.c (project\common\board\xradio_evb):		info[0].pinmux = g_pinmux_dmic;
Board_config.c (project\common\board\xradio_evb):		info[0].count = HAL_ARRAY_SIZE(g_pinmux_dmic);
Board_config.c (project\common\board\xradio_storybot):static const GPIO_PinMuxParam g_pinmux_dmic[] = {
Board_config.c (project\common\board\xradio_storybot)://	{ GPIO_PORT_A, GPIO_PIN_10, { GPIOA_P10_F4_DMIC_CLK,  GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_storybot)://	{ GPIO_PORT_A, GPIO_PIN_11, { GPIOA_P11_F4_DMIC_DATA, GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_storybot):	case HAL_DEV_MAJOR_DMIC:
Board_config.c (project\common\board\xradio_storybot):		info[0].pinmux = g_pinmux_dmic;
Board_config.c (project\common\board\xradio_storybot):		info[0].count = HAL_ARRAY_SIZE(g_pinmux_dmic);
Board_config.c (project\common\board\xradio_yt):static const GPIO_PinMuxParam g_pinmux_dmic[] = {
Board_config.c (project\common\board\xradio_yt):	{ GPIO_PORT_A, GPIO_PIN_21, { GPIOA_P21_F3_DMIC_CLK,  GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_yt):	{ GPIO_PORT_A, GPIO_PIN_22, { GPIOA_P22_F3_DMIC_DATA, GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\common\board\xradio_yt):	case HAL_DEV_MAJOR_DMIC:
Board_config.c (project\common\board\xradio_yt):		info[0].pinmux = g_pinmux_dmic;
Board_config.c (project\common\board\xradio_yt):		info[0].count = HAL_ARRAY_SIZE(g_pinmux_dmic);
Board_config.c (project\example\wlan_low_power\board):static const GPIO_PinMuxParam g_pinmux_dmic[] = {
Board_config.c (project\example\wlan_low_power\board):	{ GPIO_PORT_A, GPIO_PIN_21, { GPIOA_P21_F3_DMIC_CLK,  GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\example\wlan_low_power\board):	{ GPIO_PORT_A, GPIO_PIN_22, { GPIOA_P22_F3_DMIC_DATA, GPIO_DRIVING_LEVEL_1, GPIO_PULL_NONE } },
Board_config.c (project\example\wlan_low_power\board):	case HAL_DEV_MAJOR_DMIC:
Board_config.c (project\example\wlan_low_power\board):		info[0].pinmux = g_pinmux_dmic;
Board_config.c (project\example\wlan_low_power\board):		info[0].count = HAL_ARRAY_SIZE(g_pinmux_dmic);
CdxAtomic.h (include\cedarx\libcore\base\include): * File : CdxAtomic.h
CdxAtomic.h (include\cedarx\libcore\base\include): * Description : Atomic
CdxAtomic.h (include\cedarx\libcore\base\include):#ifndef CDX_ATOMIC_H
CdxAtomic.h (include\cedarx\libcore\base\include):#define CDX_ATOMIC_H
CdxAtomic.h (include\cedarx\libcore\base\include):} cdx_atomic_t;
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_int32 CdxAtomicInc(cdx_atomic_t *ref)
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_int32 CdxAtomicAdd(cdx_atomic_t *ref, cdx_ssize val)
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_int32 CdxAtomicDec(cdx_atomic_t *ref)
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_int32 CdxAtomicSub(cdx_atomic_t *ref, cdx_ssize val)
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_int32 CdxAtomicSet(cdx_atomic_t *ref, cdx_ssize val)
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_int32 CdxAtomicRead(cdx_atomic_t *ref)
CdxAtomic.h (include\cedarx\libcore\base\include):static inline cdx_bool CdxAtomicCAS(cdx_atomic_t *ref, cdx_ssize oldVal, cdx_ssize newVal)
CdxParser.h (include\cedarx\libcore\parser\include):    cdx_atomic_t ref;
CdxParser.h (include\cedarx\libcore\parser\include):    cdx_atomic_t ref;
CdxParser.h (include\cedarx\libcore\parser\include):    cdx_atomic_t ref;
CdxStream.h (include\cedarx\libcore\stream\include):#include <CdxAtomic.h>
Chap-new.c (src\net\lwip-2.0.3\src\netif\ppp):	/* Microsoft doesn't send their name back in the PPP packet */
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):#define CHAP_MICROSOFT		0x80
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):#define CHAP_MICROSOFT_V2	0x81
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):#define MDTYPE_MICROSOFT_V2	0x1
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):#define MDTYPE_MICROSOFT	0x2
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):    ((mdtype) & MDTYPE_MICROSOFT_V2)? CHAP_MICROSOFT_V2: \
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):    ((mdtype) & MDTYPE_MICROSOFT)? CHAP_MICROSOFT: \
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):    ((digest) == CHAP_MICROSOFT_V2)? MDTYPE_MICROSOFT_V2: \
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):    ((digest) == CHAP_MICROSOFT)? MDTYPE_MICROSOFT: \
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):    ((digest) == CHAP_MICROSOFT_V2)? (mdtype) & MDTYPE_MICROSOFT_V2: \
Chap-new.h (include\net\lwip-2.0.3\netif\ppp):    ((digest) == CHAP_MICROSOFT)? (mdtype) & MDTYPE_MICROSOFT: \
Chap.c (src\net\lwip-1.4.1\src\netif\ppp):  /* Microsoft doesn't send their name back in the PPP packet */
Chap.c (src\net\lwip-1.4.1\src\netif\ppp):  case CHAP_MICROSOFT:
Chap.h (src\net\lwip-1.4.1\src\netif\ppp):#define CHAP_MICROSOFT       0x80 /* use Microsoft-compatible alg. */
Chap_ms.c (src\net\lwip-2.0.3\src\netif\ppp): * chap_ms.c - Microsoft MS-CHAP compatible implementation.
Chap_ms.c (src\net\lwip-2.0.3\src\netif\ppp):	CHAP_MICROSOFT,		/* code */
Chap_ms.c (src\net\lwip-2.0.3\src\netif\ppp):	CHAP_MICROSOFT_V2,	/* code */
Chip.h (include\driver\chip):    DMIC_IRQn               = 21,
Chip.h (include\driver\chip):#define DMIC_BASE           (PERIPH_BASE + 0x00042400)
Chpms.c (src\net\lwip-1.4.1\src\netif\ppp):* chpms.c - Network MicroSoft Challenge Handshake Authentication Protocol program file.
Chpms.c (src\net\lwip-1.4.1\src\netif\ppp): * chap_ms.c - Microsoft MS-CHAP compatible implementation.
Chpms.h (src\net\lwip-1.4.1\src\netif\ppp):* chpms.h - Network Microsoft Challenge Handshake Protocol header file.
CMakeLists.txt (src\net\libwebsockets):# Static / Dynamic build options
CMakeLists.txt (src\net\libwebsockets):option(LWS_LINK_TESTAPPS_DYNAMIC "Link the test apps to the shared version of the library. Default is to link statically" OFF)
CMakeLists.txt (src\net\libwebsockets):# Put absolute path of dynamic libraries into the object code. Some
CMakeLists.txt (src\net\libwebsockets):	# Turn off stupid microsoft security warnings.
CMakeLists.txt (src\net\libwebsockets):		if (LWS_LINK_TESTAPPS_DYNAMIC)
CMakeLists.txt (src\net\libwebsockets):				message(FATAL_ERROR "Build of the shared library is disabled. LWS_LINK_TESTAPPS_DYNAMIC must be combined with LWS_WITH_SHARED.")
CMakeLists.txt (src\net\libwebsockets):				message(FATAL_ERROR "Build of the static library is disabled. Disabled LWS_LINK_TESTAPPS_DYNAMIC must be combined with LWS_WITH_STATIC.")
CMakeLists.txt (src\net\libwebsockets):message(" LWS_LINK_TESTAPPS_DYNAMIC = ${LWS_LINK_TESTAPPS_DYNAMIC}")
Cmd_cedarx.c (project\common\cmd):    audio_manager_handler(AUDIO_SND_CARD_DEFAULT, AUDIO_MANAGER_SET_VOLUME_LEVEL, AUDIO_IN_DEV_AMIC, 3);
Cmd_codec.c (project\common\cmd):		audio_manager_handler(CMD_CODEC_SND_CARD, AUDIO_MANAGER_SET_VOLUME_GAIN, AUDIO_IN_DEV_AMIC, VOLUME_GAIN_0dB);
Cmd_codec.c (project\common\cmd):		audio_manager_handler(CMD_CODEC_SND_CARD, AUDIO_MANAGER_SET_ROUTE,		 AUDIO_IN_DEV_AMIC, AUDIO_DEV_EN);
Cmd_codec.c (project\common\cmd):		audio_manager_handler(CMD_CODEC_SND_CARD, AUDIO_MANAGER_SET_ROUTE, AUDIO_IN_DEV_AMIC, AUDIO_DEV_DIS);
Cmd_codec.c (project\common\cmd):		/* AMIC FFT analyse */
Cmd_codec.c (project\common\cmd):		//printf("AMIC FFT buf:\n");
Cmd_codec.c (project\common\cmd):		printf("\nAMIC FFT Frequency: %f KHz, SNR: %f dB\n\n",fft_result.sig_freq/1000,fft_result.sig_power-fft_result.noise_power);
Cmd_codec.c (project\common\cmd):			audio_device = AUDIO_IN_DEV_AMIC;
Cmd_codec.c (project\common\cmd):			audio_device = AUDIO_IN_DEV_DMIC;
Cmd_codec.c (project\common\cmd):			audio_device = AUDIO_IN_DEV_AMIC;
Cmd_codec.c (project\common\cmd):			audio_device = AUDIO_IN_DEV_AMIC;
Cmd_codec.c (project\common\cmd):			audio_device = AUDIO_IN_DEV_DMIC;
Compat_rtems.h (include\net\shttpd):  It does not have SSL or CGI support, as it does not have dynamic library
Config.h (include\net\mbedtls-2.16.0\mbedtls): * based buffer to 'allocate' dynamic memory. (replaces calloc() and free()
Config.h (include\net\mbedtls-2.2.0\mbedtls): * based buffer to 'allocate' dynamic memory. (replaces calloc() and free()
Config.h (src\net\mbedtls-2.16.0\include\mbedtls): * based buffer to 'allocate' dynamic memory. (replaces calloc() and free()
Context.c (src\net\libwebsockets\lib):	/* *** This controls how many entries in the dynamic table ***
Context.c (src\net\libwebsockets\lib):	/* *** This controls how many entries in the dynamic table ***
Core_cm3.h (include\driver\cmsis):  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
Core_cm3.h (include\driver\cmsis):  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
Core_cm3.h (include\driver\cmsis):#elif defined ( __CSMC__ )		/* Cosmic */
Core_cm3.h (include\driver\cmsis):                        priority bits of the microcontroller.
Core_cm4.h (include\driver\cmsis):  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
Core_cm4.h (include\driver\cmsis):  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
Core_cm4.h (include\driver\cmsis):#elif defined ( __CSMC__ )		/* Cosmic */
Core_cm4.h (include\driver\cmsis):                        priority bits of the microcontroller.
core_cmFunc.h (include\driver\cmsis):#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
core_cmFunc.h (include\driver\cmsis):/* Cosmic specific functions */
core_cmInstr.h (include\driver\cmsis):#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
core_cmInstr.h (include\driver\cmsis):/* Cosmic specific functions */
core_cmSimd.h (include\driver\cmsis):#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
core_cmSimd.h (include\driver\cmsis):/* Cosmic specific functions */
Deprecated_definitions.h (include\kernel\freertos):#ifdef MICROBLAZE_GCC
Deprecated_definitions.h (include\kernel\freertos):	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
Detect.c (project\example\audio_reverb):#define MICROPHONE_GPIO_PORT      GPIO_PORT_A
Detect.c (project\example\audio_reverb):#define MICROPHONE_GPIO_PIN       GPIO_PIN_8
Detect.c (project\example\audio_reverb):	uint8_t level = HAL_GPIO_ReadPin(MICROPHONE_GPIO_PORT, MICROPHONE_GPIO_PIN);
Detect.c (project\example\audio_reverb):		printf("microphone is removed, stop karaok now.\n");
Detect.c (project\example\audio_reverb):		printf("microphone is inserted, start karaok now.\n");
Detect.c (project\example\audio_reverb):static void microphone_det_cb(void* arg)
Detect.c (project\example\audio_reverb):int microphone_detect_start(void)
Detect.c (project\example\audio_reverb):	HAL_GPIO_Init(MICROPHONE_GPIO_PORT, MICROPHONE_GPIO_PIN, &param);
Detect.c (project\example\audio_reverb):	irq_param.callback = microphone_det_cb;
Detect.c (project\example\audio_reverb):	HAL_GPIO_EnableIRQ(MICROPHONE_GPIO_PORT, MICROPHONE_GPIO_PIN, &irq_param);
Detect.h (project\example\audio_reverb):int microphone_detect_start(void);
Dhcp.c (src\net\lwip-1.4.1\src\core): * Dynamic Host Configuration Protocol client
Dhcp.c (src\net\lwip-2.0.3\src\core\ipv4): * Dynamic Host Configuration Protocol client
Dns.c (src\net\lwip-1.4.1\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-1.4.1\src\core):static struct local_hostlist_entry *local_hostlist_dynamic;
Dns.c (src\net\lwip-1.4.1\src\core):#else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-1.4.1\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-1.4.1\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT)
Dns.c (src\net\lwip-1.4.1\src\core):  /* Dynamic: copy entries from DNS_LOCAL_HOSTLIST_INIT to list */
Dns.c (src\net\lwip-1.4.1\src\core):      entry->next = local_hostlist_dynamic;
Dns.c (src\net\lwip-1.4.1\src\core):      local_hostlist_dynamic = entry;
Dns.c (src\net\lwip-1.4.1\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT) */
Dns.c (src\net\lwip-1.4.1\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-1.4.1\src\core):  struct local_hostlist_entry *entry = local_hostlist_dynamic;
Dns.c (src\net\lwip-1.4.1\src\core):#else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-1.4.1\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-1.4.1\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-1.4.1\src\core):  struct local_hostlist_entry *entry = local_hostlist_dynamic;
Dns.c (src\net\lwip-1.4.1\src\core):        local_hostlist_dynamic = entry->next;
Dns.c (src\net\lwip-1.4.1\src\core):  entry->next = local_hostlist_dynamic;
Dns.c (src\net\lwip-1.4.1\src\core):  local_hostlist_dynamic = entry;
Dns.c (src\net\lwip-1.4.1\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC*/
Dns.c (src\net\lwip-2.0.3\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-2.0.3\src\core):static struct local_hostlist_entry *local_hostlist_dynamic;
Dns.c (src\net\lwip-2.0.3\src\core):#else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-2.0.3\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-2.0.3\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT)
Dns.c (src\net\lwip-2.0.3\src\core):  /* Dynamic: copy entries from DNS_LOCAL_HOSTLIST_INIT to list */
Dns.c (src\net\lwip-2.0.3\src\core):      entry->next = local_hostlist_dynamic;
Dns.c (src\net\lwip-2.0.3\src\core):      local_hostlist_dynamic = entry;
Dns.c (src\net\lwip-2.0.3\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC && defined(DNS_LOCAL_HOSTLIST_INIT) */
Dns.c (src\net\lwip-2.0.3\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-2.0.3\src\core):  struct local_hostlist_entry *entry = local_hostlist_dynamic;
Dns.c (src\net\lwip-2.0.3\src\core):#else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-2.0.3\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-2.0.3\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-2.0.3\src\core):  struct local_hostlist_entry *entry = local_hostlist_dynamic;
Dns.c (src\net\lwip-2.0.3\src\core):#else /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-2.0.3\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.c (src\net\lwip-2.0.3\src\core):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.c (src\net\lwip-2.0.3\src\core):  struct local_hostlist_entry *entry = local_hostlist_dynamic;
Dns.c (src\net\lwip-2.0.3\src\core):        local_hostlist_dynamic = entry->next;
Dns.c (src\net\lwip-2.0.3\src\core):  entry->next = local_hostlist_dynamic;
Dns.c (src\net\lwip-2.0.3\src\core):  local_hostlist_dynamic = entry;
Dns.c (src\net\lwip-2.0.3\src\core):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC*/
Dns.h (include\net\lwip-1.4.1\lwip):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.h (include\net\lwip-1.4.1\lwip):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.h (include\net\lwip-1.4.1\lwip):#if DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.h (include\net\lwip-1.4.1\lwip):#endif /* DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.h (include\net\lwip-2.0.3\lwip):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.h (include\net\lwip-2.0.3\lwip):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Dns.h (include\net\lwip-2.0.3\lwip):#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Dns.h (include\net\lwip-2.0.3\lwip):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Draft-ietf-hybi-thewebsocketprotocol-00.txt (src\net\nopoll\doc):   implemented by servers simultaneously, with the server dynamically
Draft-ietf-hybi-thewebsocketprotocol-00.txt (src\net\nopoll\doc):   specification to provide a generic mechanism for dynamic author-
Draft-ietf-hybi-thewebsocketprotocol-09.txt (src\net\nopoll\doc):   dynamically selecting which subprotocol to use based on the value
Draft-ietf-hybi-thewebsocketprotocol-09.txt (src\net\nopoll\doc):   specification to provide a generic mechanism for dynamic author-
Eap.c (src\net\lwip-2.0.3\src\netif\ppp): * Copyright (c) 2001 by Sun Microsystems, Inc.
Eap.h (include\net\lwip-2.0.3\netif\ppp): * Copyright (c) 2001 by Sun Microsystems, Inc.
Efpg_efuse.c (src\efpg):#define EFPG_REGION_ATOMIC_FLAG_MASK	0x3
Efpg_efuse.c (src\efpg):#define EFPG_REGION_ATOMIC_FLAG_BITS	2
Efpg_efuse.c (src\efpg):	while ((flag & EFPG_REGION_ATOMIC_FLAG_MASK) == 0) {
Efpg_efuse.c (src\efpg):		flag = flag >> EFPG_REGION_ATOMIC_FLAG_BITS;
Efpg_efuse.c (src\efpg):	idx_max = info->flag_bits / EFPG_REGION_ATOMIC_FLAG_BITS;
Efpg_efuse.c (src\efpg):	while (((flag & EFPG_REGION_ATOMIC_FLAG_MASK) == 0) && (idx < idx_max)) {
Efpg_efuse.c (src\efpg):		flag = flag >> EFPG_REGION_ATOMIC_FLAG_BITS;
Efpg_efuse.c (src\efpg):		tmp = EFPG_REGION_ATOMIC_FLAG_MASK;
Efpg_efuse.c (src\efpg):		start_bit = info->flag_start + (idx - 1) * EFPG_REGION_ATOMIC_FLAG_BITS;
Efpg_efuse.c (src\efpg):		if ((HAL_EFUSE_Write(start_bit, EFPG_REGION_ATOMIC_FLAG_BITS, &tmp) != HAL_OK) ||
Efpg_efuse.c (src\efpg):		    (HAL_EFUSE_Read(start_bit, EFPG_REGION_ATOMIC_FLAG_BITS, &tmp) != HAL_OK)) {
Entropy.h (include\net\mbedtls-2.16.0\mbedtls): *                 dynamically at runtime by the function
Entropy.h (src\net\mbedtls-2.16.0\include\mbedtls): *                 dynamically at runtime by the function
Etharp.c (src\net\lwip-1.4.1\src\netif): *         ERR_ARG: entry wasn't a static entry but a dynamic one
Etharp.c (src\net\lwip-2.0.3\src\core\ipv4): *         ERR_ARG: entry wasn't a static entry but a dynamic one
Event_groups.h (include\kernel\freertos): * be set and then tested atomically - as is the case where event groups are
Event_groups.h (include\kernel\freertos): * Atomically set bits within an event group, then wait for a combination of
Ff.c (src\fs\fatfs):#elif _USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
Ff.c (src\fs\fatfs):#elif _USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
Ff.c (src\fs\fatfs):	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
Ff.c (src\fs\fatfs):		else {					/* Dynamic table */
Ff.c (src\fs\fatfs):				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
Ffconf.h (include\fs\fatfs):/   2: Enable LFN with dynamic working buffer on the STACK.
Ffconf.h (include\fs\fatfs):/   3: Enable LFN with dynamic working buffer on the HEAP.
FreeRTOS.h (include\kernel\freertos):#ifndef portTICK_TYPE_IS_ATOMIC
FreeRTOS.h (include\kernel\freertos):	#define portTICK_TYPE_IS_ATOMIC 0
FreeRTOS.h (include\kernel\freertos):#if( portTICK_TYPE_IS_ATOMIC == 0 )
FreeRTOS.h (include\kernel\freertos):	/* Either variables of tick type cannot be read atomically, or
FreeRTOS.h (include\kernel\freertos):	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
FreeRTOS.h (include\kernel\freertos):	/* The tick type can be read atomically, so critical sections used when the
FreeRTOSConfig.h (include\kernel\freertos)://#define configSUPPORT_DYNAMIC_ALLOCATION        1
Fs.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_FILE_READ
Fs.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
Fs.h (include\net\lwip-2.0.3\lwip\apps):#if LWIP_HTTPD_DYNAMIC_FILE_READ
Fs.h (include\net\lwip-2.0.3\lwip\apps):#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
Gettimeofday.c (src\net\libwebsockets\win32port\win32helpers):		tmpres /= 10;  /*convert into microseconds*/
Gettimeofday.c (src\net\libwebsockets\win32port\win32helpers):		tmpres -= DELTA_EPOCH_IN_MICROSECS;
Gettimeofday.h (src\net\libwebsockets\win32port\win32helpers):  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000Ui64
Gettimeofday.h (src\net\libwebsockets\win32port\win32helpers):  #define DELTA_EPOCH_IN_MICROSECS  11644473600000000ULL
Hal_ccm.h (include\driver\chip):    __IO uint32_t DMIC_MCLK_CTRL;       /* offset: 0x48, DMIC clock control register */
Hal_ccm.h (include\driver\chip):    CCM_BUS_PERIPH_BIT_DMIC         = HAL_BIT(26),  /* R/W */
Hal_ccm.h (include\driver\chip): *     - SPI0/1, SDC0/1, CE, DAUDIO, IRRX, IRTX, SYSTICK, DMIC, GPADC, CSI,
Hal_ccm.h (include\driver\chip):/* CCM->DMIC_MCLK_CTRL */
Hal_ccm.h (include\driver\chip):void HAL_CCM_DMIC_EnableMClock(void);
Hal_ccm.h (include\driver\chip):void HAL_CCM_DMIC_DisableMClock(void);
Hal_chip.h (include\driver\chip):#include "driver/chip/hal_dmic.h"
Hal_dev.h (include\driver):    HAL_DEV_MAJOR_DMIC,
Hal_dma.h (include\driver\chip):    DMA_PERIPH_DMIC             = 8U,
Hal_dmic.c (src\driver\chip):  * @file  hal_dmic.c
Hal_dmic.c (src\driver\chip):#include "driver/chip/hal_dmic.h"
Hal_dmic.c (src\driver\chip):#define DMIC_DBG_ON                0
Hal_dmic.c (src\driver\chip):#if (DMIC_DBG_ON == 1)
Hal_dmic.c (src\driver\chip):#define DMIC_DEBUG(fmt, arg...)    HAL_LOG(DMIC_DBG_ON, "[DMIC] "fmt, ##arg)
Hal_dmic.c (src\driver\chip):#define DMIC_DEBUG(fmt, arg...)
Hal_dmic.c (src\driver\chip):#define DMIC_ERROR(fmt, arg...)    HAL_LOG(1, "[DMIC] "fmt, ##arg)
Hal_dmic.c (src\driver\chip):#define DMIC_IT_ERROR(fmt, arg...) HAL_IT_LOG(1, "[DMIC] "fmt, ##arg)
Hal_dmic.c (src\driver\chip):#define DMIC_IT_ERROR              DMIC_ERROR
Hal_dmic.c (src\driver\chip):        const DMIC_HWParam *hwParam;
Hal_dmic.c (src\driver\chip):        DMIC_DataParam     dataParam;
Hal_dmic.c (src\driver\chip):} DMIC_Private;
Hal_dmic.c (src\driver\chip):        DMIC_PLL_24M = 0U,
Hal_dmic.c (src\driver\chip):        DMIC_PLL_22M = 1U,
Hal_dmic.c (src\driver\chip):} DMIC_PLLMode;
Hal_dmic.c (src\driver\chip):} HOSC_DMIC_Type;
Hal_dmic.c (src\driver\chip):#define DMIC_MEMCPY                           HAL_Memcpy
Hal_dmic.c (src\driver\chip):#define DMIC_MALLOC                           HAL_Malloc
Hal_dmic.c (src\driver\chip):#define DMIC_FREE                             HAL_Free
Hal_dmic.c (src\driver\chip):#define DMIC_MEMSET                           HAL_Memset
Hal_dmic.c (src\driver\chip):#define DMIC_OVERRUN_THRESHOLD              3
Hal_dmic.c (src\driver\chip):#ifdef RESERVERD_MEMORY_FOR_DMIC
Hal_dmic.c (src\driver\chip):static uint8_t DMIC_BUF[DMIC_BUF_LENGTH];
Hal_dmic.c (src\driver\chip):DMIC_Private gDMICPrivate;
Hal_dmic.c (src\driver\chip):static uint32_t DMIC_BUF_LENGTH = 0;
Hal_dmic.c (src\driver\chip):static const DMIC_HWParam gHwParam = {
Hal_dmic.c (src\driver\chip):        DMIC_CTLR_DMICFDT_5MS,
Hal_dmic.c (src\driver\chip):        DMIC_FIFOCR_MODE1,
Hal_dmic.c (src\driver\chip):static const HOSC_DMIC_Type dmic_hosc_aud_type[] = {
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_26M, DMIC_PLL_24M, PRCM_AUD_PLL24M_PARAM_HOSC26M, PRCM_AUD_PLL24M_PAT_PARAM_HOSC26M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_26M, DMIC_PLL_22M, PRCM_AUD_PLL22M_PARAM_HOSC26M, PRCM_AUD_PLL22M_PAT_PARAM_HOSC26M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_24M, DMIC_PLL_24M, PRCM_AUD_PLL24M_PARAM_HOSC24M, PRCM_AUD_PLL24M_PAT_PARAM_HOSC24M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_24M, DMIC_PLL_22M, PRCM_AUD_PLL22M_PARAM_HOSC24M, PRCM_AUD_PLL22M_PAT_PARAM_HOSC24M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_40M, DMIC_PLL_24M, PRCM_AUD_PLL24M_PARAM_HOSC40M, PRCM_AUD_PLL24M_PAT_PARAM_HOSC40M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_40M, DMIC_PLL_22M, PRCM_AUD_PLL22M_PARAM_HOSC40M, PRCM_AUD_PLL22M_PAT_PARAM_HOSC40M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_52M, DMIC_PLL_24M, PRCM_AUD_PLL24M_PARAM_HOSC52M, PRCM_AUD_PLL24M_PAT_PARAM_HOSC52M},
Hal_dmic.c (src\driver\chip):        {HOSC_CLOCK_52M, DMIC_PLL_22M, PRCM_AUD_PLL22M_PARAM_HOSC52M, PRCM_AUD_PLL22M_PAT_PARAM_HOSC52M},
Hal_dmic.c (src\driver\chip):static uint32_t DMIC_PLLAUDIO_Update(DMIC_PLLMode pll)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        if (pll != DMIC_PLL_24M &&  pll != DMIC_PLL_22M)
Hal_dmic.c (src\driver\chip):        for (i = 0; i < HAL_ARRAY_SIZE(dmic_hosc_aud_type); i++) {
Hal_dmic.c (src\driver\chip):                if ((dmic_hosc_aud_type[i].hosc == hoscClock) && (dmic_hosc_aud_type[i].audio == pll)) {
Hal_dmic.c (src\driver\chip):                        dmicPrivate->audioPllParam = dmic_hosc_aud_type[i].pllParam;
Hal_dmic.c (src\driver\chip):                        dmicPrivate->audioPllPatParam = dmic_hosc_aud_type[i].pllPatParam;
Hal_dmic.c (src\driver\chip):        if (i == HAL_ARRAY_SIZE(dmic_hosc_aud_type)) {
Hal_dmic.c (src\driver\chip):                DMIC_ERROR("Update audio pll failed....\n");
Hal_dmic.c (src\driver\chip):static void HAL_DMIC_Trigger(bool enable);
Hal_dmic.c (src\driver\chip):static int DMIC_DMA_BUFFER_CHECK_Threshold()
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->halfCounter >= DMIC_OVERRUN_THRESHOLD ||
Hal_dmic.c (src\driver\chip):                dmicPrivate->endCounter >= DMIC_OVERRUN_THRESHOLD) {
Hal_dmic.c (src\driver\chip):                HAL_DMIC_Trigger(0);
Hal_dmic.c (src\driver\chip):                dmicPrivate->isRunning = 0;
Hal_dmic.c (src\driver\chip):                dmicPrivate->halfCounter = 0;
Hal_dmic.c (src\driver\chip):                dmicPrivate->endCounter = 0;
Hal_dmic.c (src\driver\chip):                dmicPrivate->lastReadPointer = dmicPrivate->usrBuf;
Hal_dmic.c (src\driver\chip):                DMIC_IT_ERROR("Rx : overrun and stop dma rx...\n");
Hal_dmic.c (src\driver\chip):  * @brief DMA DMIC receive process half complete callback
Hal_dmic.c (src\driver\chip):static void DMIC_DMAHalfCallback(void *arg)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        dmicPrivate->halfCounter ++;
Hal_dmic.c (src\driver\chip):        if (DMIC_DMA_BUFFER_CHECK_Threshold() != 0)
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->isSemaphore == true) {
Hal_dmic.c (src\driver\chip):                dmicPrivate->isSemaphore = false;
Hal_dmic.c (src\driver\chip):  * @brief DMA DMIC receive process complete callback
Hal_dmic.c (src\driver\chip):static void DMIC_DMAEndCallback(void *arg)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        dmicPrivate->endCounter ++;
Hal_dmic.c (src\driver\chip):        if (DMIC_DMA_BUFFER_CHECK_Threshold() != 0)
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->isSemaphore == true) {
Hal_dmic.c (src\driver\chip):                dmicPrivate->isSemaphore = false;
Hal_dmic.c (src\driver\chip):static void DMIC_DMAStart(DMA_Channel chan, uint32_t srcAddr, uint32_t dstAddr, uint32_t datalen)
Hal_dmic.c (src\driver\chip):static void DMIC_DMAStop(DMA_Channel chan)
Hal_dmic.c (src\driver\chip):static void DMIC_DMASet(DMA_Channel channel)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):                        DMA_PERIPH_DMIC);
Hal_dmic.c (src\driver\chip):        dmaParam.endCallback = DMIC_DMAEndCallback;
Hal_dmic.c (src\driver\chip):        dmaParam.halfCallback = DMIC_DMAHalfCallback;
Hal_dmic.c (src\driver\chip):        dmaParam.endArg = &(dmicPrivate->rxReady);
Hal_dmic.c (src\driver\chip):        dmaParam.halfArg = &(dmicPrivate->rxReady);
Hal_dmic.c (src\driver\chip):  * @brief enbale/disable DMIC controller.
Hal_dmic.c (src\driver\chip):static void HAL_DMIC_Trigger(bool enable)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):                HAL_SET_BIT(DMIC->FIFO_CTR, DMIC_FIFOCR_FIFO_FLUSH_BIT);
Hal_dmic.c (src\driver\chip):                if (dmicPrivate->dataParam.channels > 1) {
Hal_dmic.c (src\driver\chip):                        HAL_SET_BIT(DMIC->DMIC_EN, DMIC_ECR_DATA0_CHL_EN_BIT|DMIC_ECR_DATA0_CHR_EN_BIT);
Hal_dmic.c (src\driver\chip):                        HAL_SET_BIT(DMIC->DMIC_EN, DMIC_ECR_DATA0_CHL_EN_BIT);
Hal_dmic.c (src\driver\chip):                HAL_SET_BIT(DMIC->DMIC_INTC, DMIC_ICR_FIFO_DRQ_EN_BIT);
Hal_dmic.c (src\driver\chip):                DMIC_DMAStart(dmicPrivate->DMAChan, (uint32_t)&(DMIC->DMIC_DATA),
Hal_dmic.c (src\driver\chip):                             (uint32_t)dmicPrivate->usrBuf, dmicPrivate->length);
Hal_dmic.c (src\driver\chip):                DMIC_DMAStop(dmicPrivate->DMAChan);
Hal_dmic.c (src\driver\chip):                HAL_CLR_BIT(DMIC->DMIC_INTC, DMIC_ICR_FIFO_DRQ_EN_BIT);
Hal_dmic.c (src\driver\chip):                HAL_CLR_BIT(DMIC->DMIC_EN, DMIC_ECR_DATA0_CHL_EN_BIT|DMIC_ECR_DATA0_CHR_EN_BIT);
Hal_dmic.c (src\driver\chip):int32_t HAL_DMIC_Read_DMA(uint8_t *buf, uint32_t size)
Hal_dmic.c (src\driver\chip):        if (!buf || size < DMIC_BUF_LENGTH/2)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        uint32_t toRead = DMIC_BUF_LENGTH/2;
Hal_dmic.c (src\driver\chip):                if (!dmicPrivate->isRunning) {
Hal_dmic.c (src\driver\chip):                        dmicPrivate->lastReadPointer = dmicPrivate->usrBuf;
Hal_dmic.c (src\driver\chip):                        DMIC_DEBUG("Rx: record start...\n");
Hal_dmic.c (src\driver\chip):                        dmicPrivate->isRunning = 1;
Hal_dmic.c (src\driver\chip):                        HAL_DMIC_Trigger(1);
Hal_dmic.c (src\driver\chip):                        readPointer = dmicPrivate->lastReadPointer;
Hal_dmic.c (src\driver\chip):                        if (dmicPrivate->halfCounter && dmicPrivate->endCounter) {
Hal_dmic.c (src\driver\chip):                                dmicPrivate->halfCounter = 0;
Hal_dmic.c (src\driver\chip):                                dmicPrivate->endCounter = 0;
Hal_dmic.c (src\driver\chip):                                if (dmicPrivate->dmaPointer == dmicPrivate->usrBuf) {
Hal_dmic.c (src\driver\chip):                                        readPointer = dmicPrivate->usrBuf + DMIC_BUF_LENGTH/2;
Hal_dmic.c (src\driver\chip):                                        readPointer = dmicPrivate->usrBuf;
Hal_dmic.c (src\driver\chip):                        } else if (dmicPrivate->halfCounter ) {
Hal_dmic.c (src\driver\chip):                                dmicPrivate->halfCounter --;
Hal_dmic.c (src\driver\chip):                        } else if (dmicPrivate->endCounter) {
Hal_dmic.c (src\driver\chip):                                dmicPrivate->endCounter --;
Hal_dmic.c (src\driver\chip):                                dmicPrivate->isSemaphore = true;
Hal_dmic.c (src\driver\chip):                                HAL_SemaphoreWait(&dmicPrivate->rxReady, HAL_WAIT_FOREVER);
Hal_dmic.c (src\driver\chip):                                if (dmicPrivate->halfCounter)
Hal_dmic.c (src\driver\chip):                                        dmicPrivate->halfCounter--;
Hal_dmic.c (src\driver\chip):                                if (dmicPrivate->endCounter)
Hal_dmic.c (src\driver\chip):                                        dmicPrivate->endCounter--;
Hal_dmic.c (src\driver\chip):                        DMIC_MEMCPY(writeBuf, readPointer, toRead);
Hal_dmic.c (src\driver\chip):                            DMIC_ERROR("overrun...\n");
Hal_dmic.c (src\driver\chip):                        dmicPrivate->lastReadPointer = readPointer +  toRead;
Hal_dmic.c (src\driver\chip):                        if (dmicPrivate->lastReadPointer >= dmicPrivate->usrBuf + DMIC_BUF_LENGTH)
Hal_dmic.c (src\driver\chip):                                dmicPrivate->lastReadPointer = dmicPrivate->usrBuf;
Hal_dmic.c (src\driver\chip):  * @brief DMIC peripheral Init
Hal_dmic.c (src\driver\chip):  * @param param: pointer to a DMIC_HWParam structure that contains
Hal_dmic.c (src\driver\chip):static inline HAL_Status DMIC_HwInit(const DMIC_HWParam *param)
Hal_dmic.c (src\driver\chip):        HAL_MODIFY_REG(DMIC->DMIC_CTR, DMIC_CTLR_DMICFDT_MASK,param->delayTime);
Hal_dmic.c (src\driver\chip):        HAL_MODIFY_REG(DMIC->FIFO_CTR, DMIC_FIFOCR_MODE_MASK|DMIC_FIFOCR_TRG_LEVEL_MASK,
Hal_dmic.c (src\driver\chip):                        param->fifoMode|DMIC_FIFOCR_TRG_LEVEL(param->triggerLevel));
Hal_dmic.c (src\driver\chip):        HAL_MODIFY_REG(DMIC->DATA0_DATA1_VOL_CTR, DMIC_DATA0L_VOL_MASK|DMIC_DATA0R_VOL_MASK,
Hal_dmic.c (src\driver\chip):                        DMIC_DATA0L_VOL(param->volumeGain)|DMIC_DATA0R_VOL(param->volumeGain));
Hal_dmic.c (src\driver\chip):                HAL_SET_BIT(DMIC->HPF_EN_CTR, DMIC_HPF_DATA0_CHL_EN_BIT|DMIC_HPF_DATA0_CHR_EN_BIT);
Hal_dmic.c (src\driver\chip):        HAL_SET_BIT(DMIC->DMIC_EN, DMIC_ECR_GLOBE_EN);
Hal_dmic.c (src\driver\chip):  * @brief DeInitializes the DMIC peripheral
Hal_dmic.c (src\driver\chip):  * @param param: pointer to a DMIC_HWParam structure that contains
Hal_dmic.c (src\driver\chip):static inline HAL_Status DMIC_HwDeInit(const DMIC_HWParam *param)
Hal_dmic.c (src\driver\chip):                HAL_CLR_BIT(DMIC->HPF_EN_CTR, DMIC_HPF_DATA0_CHL_EN_BIT|DMIC_HPF_DATA0_CHR_EN_BIT);
Hal_dmic.c (src\driver\chip):        HAL_CLR_BIT(DMIC->DMIC_EN, DMIC_ECR_GLOBE_EN);
Hal_dmic.c (src\driver\chip):  * @brief Open the DMIC module according to the specified parameters
Hal_dmic.c (src\driver\chip):  *         in the DMIC_DataParam.
Hal_dmic.c (src\driver\chip):  * @param param: pointer to a DMIC_DataParam structure that contains
Hal_dmic.c (src\driver\chip):HAL_Status HAL_DMIC_Open(DMIC_DataParam *param)
Hal_dmic.c (src\driver\chip):        DMIC_DEBUG("Dmic open.\n");
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->isInitiate == true) {
Hal_dmic.c (src\driver\chip):                DMIC_ERROR("DMIC opened already,faild...\n");
Hal_dmic.c (src\driver\chip):        dmicPrivate->isInitiate = true;
Hal_dmic.c (src\driver\chip):        DMIC_MEMCPY(&(dmicPrivate->dataParam), param, sizeof(*param));
Hal_dmic.c (src\driver\chip):        DMIC_BUF_LENGTH = param->bufSize;
Hal_dmic.c (src\driver\chip):        dmicPrivate->DMAChan = DMA_CHANNEL_INVALID;
Hal_dmic.c (src\driver\chip):        dmicPrivate->length = DMIC_BUF_LENGTH;
Hal_dmic.c (src\driver\chip):#ifdef RESERVERD_MEMORY_FOR_DMIC
Hal_dmic.c (src\driver\chip):        dmicPrivate->usrBuf = DMIC_BUF;
Hal_dmic.c (src\driver\chip):        dmicPrivate->usrBuf = DMIC_MALLOC(DMIC_BUF_LENGTH);
Hal_dmic.c (src\driver\chip):        if(dmicPrivate->usrBuf)
Hal_dmic.c (src\driver\chip):                DMIC_MEMSET(dmicPrivate->usrBuf,0,DMIC_BUF_LENGTH);
Hal_dmic.c (src\driver\chip):                DMIC_ERROR("Malloc buf(for DMA),faild...\n");
Hal_dmic.c (src\driver\chip):        dmicPrivate->DMAChan = HAL_DMA_Request();
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->DMAChan == DMA_CHANNEL_INVALID) {
Hal_dmic.c (src\driver\chip):                DMIC_ERROR("Request DMA channel(for DMIC),faild...\n");
Hal_dmic.c (src\driver\chip):                DMIC_FREE(dmicPrivate->usrBuf);
Hal_dmic.c (src\driver\chip):        HAL_SemaphoreInitBinary(&dmicPrivate->rxReady);
Hal_dmic.c (src\driver\chip):        HAL_MODIFY_REG(DMIC->CH_NUM, DMIC_CH_NUM_MASK,(param->channels - 1));
Hal_dmic.c (src\driver\chip):                HAL_SET_BIT(DMIC->DMIC_EN, DMIC_ECR_DATA0_CHL_EN_BIT|DMIC_ECR_DATA0_CHR_EN_BIT);
Hal_dmic.c (src\driver\chip):                HAL_MODIFY_REG(DMIC->CH_MAP, DMIC_CMR_CH0_MAP_MASK(0)| DMIC_CMR_CH0_MAP_MASK(1),
Hal_dmic.c (src\driver\chip):                                DMIC_CMR_CH0_MAP(0)|DMIC_CMR_CH0_MAP(1));
Hal_dmic.c (src\driver\chip):                HAL_SET_BIT(DMIC->DMIC_EN, DMIC_ECR_DATA0_CHL_EN_BIT);
Hal_dmic.c (src\driver\chip):                HAL_MODIFY_REG(DMIC->CH_MAP, DMIC_CMR_CH0_MAP_MASK(0),DMIC_CMR_CH0_MAP(0));
Hal_dmic.c (src\driver\chip):                case DMIC_SR48KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR24KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR12KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR32KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR16KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR8KHZ:
Hal_dmic.c (src\driver\chip):                        DMIC_PLLAUDIO_Update(DMIC_PLL_24M);
Hal_dmic.c (src\driver\chip):                        HAL_PRCM_SetAudioPLLParam(dmicPrivate->audioPllParam);
Hal_dmic.c (src\driver\chip):                        HAL_PRCM_SetAudioPLLPatternParam(dmicPrivate->audioPllPatParam);
Hal_dmic.c (src\driver\chip):                case DMIC_SR44KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR22KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR11KHZ:
Hal_dmic.c (src\driver\chip):                        DMIC_PLLAUDIO_Update(DMIC_PLL_22M);
Hal_dmic.c (src\driver\chip):                        HAL_PRCM_SetAudioPLLParam(dmicPrivate->audioPllParam);
Hal_dmic.c (src\driver\chip):                        HAL_PRCM_SetAudioPLLPatternParam(dmicPrivate->audioPllPatParam);
Hal_dmic.c (src\driver\chip):                        DMIC_ERROR("Invalued Samplerate...\n");
Hal_dmic.c (src\driver\chip):        /* Set DMIC oversample rate*/
Hal_dmic.c (src\driver\chip):                case DMIC_SR48KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR24KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR44KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR22KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR32KHZ:
Hal_dmic.c (src\driver\chip):                        HAL_MODIFY_REG(DMIC->DMIC_CTR, DMIC_CTLR_OVERSAMPLE_RATE_MASK,
Hal_dmic.c (src\driver\chip):                                       DMIC_CTLR_OVERSAMPLE_RATE64);
Hal_dmic.c (src\driver\chip):                case DMIC_SR16KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR12KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR8KHZ:
Hal_dmic.c (src\driver\chip):                case DMIC_SR11KHZ:
Hal_dmic.c (src\driver\chip):                        HAL_MODIFY_REG(DMIC->DMIC_CTR, DMIC_CTLR_OVERSAMPLE_RATE_MASK,
Hal_dmic.c (src\driver\chip):                                       DMIC_CTLR_OVERSAMPLE_RATE128);
Hal_dmic.c (src\driver\chip):        if (param->sampleRate == DMIC_SR44KHZ) {
Hal_dmic.c (src\driver\chip):                param->sampleRate = DMIC_SR48KHZ;
Hal_dmic.c (src\driver\chip):        } else if (param->sampleRate == DMIC_SR22KHZ) {
Hal_dmic.c (src\driver\chip):                param->sampleRate = DMIC_SR24KHZ;
Hal_dmic.c (src\driver\chip):        } else if (param->sampleRate == DMIC_SR11KHZ) {
Hal_dmic.c (src\driver\chip):                param->sampleRate = DMIC_SR12KHZ;
Hal_dmic.c (src\driver\chip):        HAL_MODIFY_REG(DMIC->DMIC_SR, DMIC_SR_MASK,param->sampleRate);
Hal_dmic.c (src\driver\chip):        HAL_MODIFY_REG(DMIC->FIFO_CTR, DMIC_FIFOCR_SAMPLE_RES_MASK,param->resolution);
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->DMAChan != DMA_CHANNEL_INVALID)
Hal_dmic.c (src\driver\chip):                DMIC_DMASet(dmicPrivate->DMAChan);
Hal_dmic.c (src\driver\chip):  * @brief Close the DMIC module
Hal_dmic.c (src\driver\chip):void HAL_DMIC_Close()
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        HAL_DMIC_Trigger(false);
Hal_dmic.c (src\driver\chip):        dmicPrivate->isRunning = false;
Hal_dmic.c (src\driver\chip):        dmicPrivate->isInitiate = false;
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->DMAChan != DMA_CHANNEL_INVALID) {
Hal_dmic.c (src\driver\chip):                HAL_DMA_DeInit(dmicPrivate->DMAChan);
Hal_dmic.c (src\driver\chip):                HAL_DMA_Release(dmicPrivate->DMAChan);
Hal_dmic.c (src\driver\chip):                dmicPrivate->DMAChan = DMA_CHANNEL_INVALID;
Hal_dmic.c (src\driver\chip):        DMIC_MEMSET(&(dmicPrivate->dataParam), 0, sizeof(DMIC_DataParam));
Hal_dmic.c (src\driver\chip):#ifndef RESERVERD_MEMORY_FOR_DMIC
Hal_dmic.c (src\driver\chip):        DMIC_FREE(dmicPrivate->usrBuf);
Hal_dmic.c (src\driver\chip):        dmicPrivate->usrBuf= NULL;
Hal_dmic.c (src\driver\chip):        dmicPrivate->length = 0;
Hal_dmic.c (src\driver\chip):        dmicPrivate->halfCounter = 0;
Hal_dmic.c (src\driver\chip):        dmicPrivate->endCounter = 0;
Hal_dmic.c (src\driver\chip):  * @brief DMIC PINS Init
Hal_dmic.c (src\driver\chip):static inline HAL_Status DMIC_PINS_Init()
Hal_dmic.c (src\driver\chip):        return HAL_BoardIoctl(HAL_BIR_PINMUX_INIT, HAL_MKDEV(HAL_DEV_MAJOR_DMIC, 0), 0);
Hal_dmic.c (src\driver\chip):  * @brief DMIC PINS DeInit
Hal_dmic.c (src\driver\chip):static inline HAL_Status DMIC_PINS_DeInit()
Hal_dmic.c (src\driver\chip):        return HAL_BoardIoctl(HAL_BIR_PINMUX_DEINIT, HAL_MKDEV(HAL_DEV_MAJOR_DMIC, 0), 0);
Hal_dmic.c (src\driver\chip):static int dmic_suspend(struct soc_device *dev, enum suspend_state_t state)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):                DMIC_HwDeInit(dmicPrivate->hwParam);
Hal_dmic.c (src\driver\chip):                DMIC_PINS_DeInit();
Hal_dmic.c (src\driver\chip):                HAL_CCM_DMIC_DisableMClock();
Hal_dmic.c (src\driver\chip):                HAL_CCM_BusDisablePeriphClock(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):                HAL_CCM_BusForcePeriphReset(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):static int dmic_resume(struct soc_device *dev, enum suspend_state_t state)
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):                DMIC_PLLAUDIO_Update(DMIC_PLL_24M);
Hal_dmic.c (src\driver\chip):                HAL_PRCM_SetAudioPLLParam(dmicPrivate->audioPllParam);
Hal_dmic.c (src\driver\chip):                HAL_PRCM_SetAudioPLLPatternParam(dmicPrivate->audioPllPatParam);
Hal_dmic.c (src\driver\chip):                HAL_CCM_BusEnablePeriphClock(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):                HAL_CCM_BusReleasePeriphReset(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):                HAL_CCM_DMIC_EnableMClock();
Hal_dmic.c (src\driver\chip):                DMIC_PINS_Init();
Hal_dmic.c (src\driver\chip):                DMIC_HwInit(dmicPrivate->hwParam);
Hal_dmic.c (src\driver\chip):static const struct soc_device_driver dmic_drv = {
Hal_dmic.c (src\driver\chip):        .name    = "DMIC",
Hal_dmic.c (src\driver\chip):        .suspend = dmic_suspend,
Hal_dmic.c (src\driver\chip):        .resume  = dmic_resume,
Hal_dmic.c (src\driver\chip):static struct soc_device dmic_dev = {
Hal_dmic.c (src\driver\chip):        .name   = "DMIC",
Hal_dmic.c (src\driver\chip):        .driver = &dmic_drv,
Hal_dmic.c (src\driver\chip):#define DMIC_DEV (&dmic_dev)
Hal_dmic.c (src\driver\chip):  * @brief Initializes the DMIC according to the specified parameters
Hal_dmic.c (src\driver\chip):  *         in the DMIC_Param.
Hal_dmic.c (src\driver\chip):  * @param  param: pointer to a DMIC_Param structure that contains
Hal_dmic.c (src\driver\chip):  *         the hw configuration information for DMIC controller
Hal_dmic.c (src\driver\chip):HAL_Status HAL_DMIC_Init(DMIC_Param *param)
Hal_dmic.c (src\driver\chip):        DMIC_DEBUG("Dmic init.\n");
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        if (dmicPrivate->isHwInit)
Hal_dmic.c (src\driver\chip):        DMIC_MEMSET(dmicPrivate, 0, sizeof(DMIC_Private));
Hal_dmic.c (src\driver\chip):        dmicPrivate->isHwInit = true;
Hal_dmic.c (src\driver\chip):                dmicPrivate->hwParam = &gHwParam;
Hal_dmic.c (src\driver\chip):                dmicPrivate->hwParam = param->hwParam;
Hal_dmic.c (src\driver\chip):        DMIC_PLLAUDIO_Update(DMIC_PLL_24M);
Hal_dmic.c (src\driver\chip):        HAL_PRCM_SetAudioPLLParam(dmicPrivate->audioPllParam);
Hal_dmic.c (src\driver\chip):        HAL_PRCM_SetAudioPLLPatternParam(dmicPrivate->audioPllPatParam);
Hal_dmic.c (src\driver\chip):        HAL_CCM_BusEnablePeriphClock(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):        HAL_CCM_BusReleasePeriphReset(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):        HAL_CCM_DMIC_EnableMClock();
Hal_dmic.c (src\driver\chip):        DMIC_PINS_Init();
Hal_dmic.c (src\driver\chip):        pm_register_ops(DMIC_DEV);
Hal_dmic.c (src\driver\chip):        ret = DMIC_HwInit(dmicPrivate->hwParam);
Hal_dmic.c (src\driver\chip):  * @brief DeInitializes the DMIC module
Hal_dmic.c (src\driver\chip):void HAL_DMIC_DeInit()
Hal_dmic.c (src\driver\chip):        DMIC_DEBUG("Dmic deinit.\n");
Hal_dmic.c (src\driver\chip):        DMIC_Private *dmicPrivate = &gDMICPrivate;
Hal_dmic.c (src\driver\chip):        DMIC_HwDeInit(dmicPrivate->hwParam);
Hal_dmic.c (src\driver\chip):        DMIC_PINS_DeInit();
Hal_dmic.c (src\driver\chip):        HAL_CCM_DMIC_DisableMClock();
Hal_dmic.c (src\driver\chip):        HAL_CCM_BusDisablePeriphClock(CCM_BUS_PERIPH_BIT_DMIC);
Hal_dmic.c (src\driver\chip):        DMIC_MEMSET(dmicPrivate, 0, sizeof(DMIC_Private));
Hal_dmic.h (include\driver\chip):  * @file  hal_dmic.h
Hal_dmic.h (include\driver\chip):#ifndef _DRIVER_CHIP_HAL_DMIC_H_
Hal_dmic.h (include\driver\chip):#define _DRIVER_CHIP_HAL_DMIC_H_
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_EN;               /* DMIC enable control register      Address offset: 0x0000  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_SR;               /* DMIC sample rate register         Adrress offset: 0x0004  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_CTR;              /* DMIC control register           Address offset: 0x0008  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_DATA;             /* DMIC data register              Address offset: 0x0010  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_INTC;             /* DMIC interrupt control register       Address offset: 0x0014  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_INTS;             /* DMIC interrupt status register        Address offset: 0x0018  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t FIFO_CTR;              /* DMIC FIFO control register          Address offset: 0x001C  */
Hal_dmic.h (include\driver\chip):	__I uint32_t  FIFO_STA;              /* DMIC FIFO status register         Address offset: 0x0020  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t CH_NUM;                /* DMIC channel numbers register       Address offset: 0x0024  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t CH_MAP;                /* DMIC channel mapping register       Address offset: 0x0028  */
Hal_dmic.h (include\driver\chip):	__IO uint32_t DMIC_CNT;              /* DMIC counter register           Address offset: 0x002C  */
Hal_dmic.h (include\driver\chip):} DMIC_T;
Hal_dmic.h (include\driver\chip):#define DMIC                                  ((DMIC_T *)DMIC_BASE)
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_ECR register(0x0000)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA0_CHL_EN_BIT                         HAL_BIT(0)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA0_CHR_EN_BIT                         HAL_BIT(1)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA1_CHL_EN_BIT                         HAL_BIT(2)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA1_CHR_EN_BIT                         HAL_BIT(3)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA2_CHL_EN_BIT                         HAL_BIT(4)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA2_CHR_EN_BIT                         HAL_BIT(5)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA3_CHL_EN_BIT                         HAL_BIT(6)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_DATA3_CHR_EN_BIT                         HAL_BIT(7)
Hal_dmic.h (include\driver\chip):#define DMIC_ECR_GLOBE_EN                                 HAL_BIT(8)
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_SRR register (0x0004)
Hal_dmic.h (include\driver\chip):#define DMIC_SR_SHIFT                                     (0)
Hal_dmic.h (include\driver\chip):#define DMIC_SR_MASK                                      (0x7U << DMIC_SR_SHIFT)
Hal_dmic.h (include\driver\chip):  * @brief Dmic sample rate definition
Hal_dmic.h (include\driver\chip):	DMIC_SR48KHZ = (0X0U << DMIC_SR_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_SR44KHZ = (0X8U << DMIC_SR_SHIFT),/*44100*/
Hal_dmic.h (include\driver\chip):	DMIC_SR24KHZ = (0X2U << DMIC_SR_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_SR22KHZ = (0X9U << DMIC_SR_SHIFT),/*22050*/
Hal_dmic.h (include\driver\chip):	DMIC_SR12KHZ = (0X4U << DMIC_SR_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_SR11KHZ = (0XaU << DMIC_SR_SHIFT),/*11025*/
Hal_dmic.h (include\driver\chip):	DMIC_SR32KHZ = (0X1U << DMIC_SR_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_SR16KHZ = (0X3U << DMIC_SR_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_SR8KHZ  = (0X5U << DMIC_SR_SHIFT),
Hal_dmic.h (include\driver\chip):} DMIC_SampleRate;
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_CTLR register (0X0008)
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_OVERSAMPLE_RATE_SHIFT                   (0)
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_OVERSAMPLE_RATE_MASK                    (0x1U << DMIC_CTLR_OVERSAMPLE_RATE_SHIFT)
Hal_dmic.h (include\driver\chip):	 DMIC_CTLR_OVERSAMPLE_RATE64  = (0X1U << DMIC_CTLR_OVERSAMPLE_RATE_SHIFT),
Hal_dmic.h (include\driver\chip):	 DMIC_CTLR_OVERSAMPLE_RATE128 = (0X0U << DMIC_CTLR_OVERSAMPLE_RATE_SHIFT),
Hal_dmic.h (include\driver\chip):} DMIC_OverSampleRate;
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DATA0_SWAP_BIT                           HAL_BIT(4)       /* bit4, data0 left data and right data sweep enable */
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DATA1_SWAP_BIT                           HAL_BIT(5)       /* bit5, data1 left data and right data sweep enable */
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DATA2_SWAP_BIT                           HAL_BIT(6)       /* bit6, data2 left data and right data sweep enable */
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DATA3_SWAP_BIT                           HAL_BIT(7)       /* bit7, data3 left data and right data sweep enable */
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DMICDFEN_BIT                             HAL_BIT(8)       /* bit8, dmic fifo delay function for writing data after globe_en */
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DMICFDT_SHIFT                            (9)
Hal_dmic.h (include\driver\chip):#define DMIC_CTLR_DMICFDT_MASK                             (0x3U << DMIC_CTLR_OVERSAMPLE_RATE_SHIFT)
Hal_dmic.h (include\driver\chip):	 DMIC_CTLR_DMICFDT_5MS   = (0X0U << DMIC_CTLR_DMICFDT_SHIFT),
Hal_dmic.h (include\driver\chip):	 DMIC_CTLR_DMICFDT_10MS  = (0X1U << DMIC_CTLR_DMICFDT_SHIFT),
Hal_dmic.h (include\driver\chip):	 DMIC_CTLR_DMICFDT_200MS = (0X2U << DMIC_CTLR_DMICFDT_SHIFT),
Hal_dmic.h (include\driver\chip):	 DMIC_CTLR_DMICFDT_30MS  = (0X3U << DMIC_CTLR_DMICFDT_SHIFT),
Hal_dmic.h (include\driver\chip):} DMIC_CtrlDmicFDT;
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_ICR register  (0x14)
Hal_dmic.h (include\driver\chip):#define DMIC_ICR_DATA_IRQ_EN_BIT                           HAL_BIT(0)       /* bit0, dmic fifo data available irq enable */
Hal_dmic.h (include\driver\chip):#define DMIC_ICR_OVERRUN_IRQ_EN_BIT                        HAL_BIT(1)       /* bit1, dmic fifo fifo overrun irq enable */
Hal_dmic.h (include\driver\chip):#define DMIC_ICR_FIFO_DRQ_EN_BIT                           HAL_BIT(2)       /* bit2, dmic fifo data available drq enable */
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_ISR register (0X18)
Hal_dmic.h (include\driver\chip):#define DMIC_ISR_DATA_IRQ_PEND_BIT                         HAL_BIT(0)       /* bit0, dmic fifo data available pending interrupt */
Hal_dmic.h (include\driver\chip):#define DMIC_ISR_OVERRUN_IRQ_PEND_BIT                      HAL_BIT(1)       /* bit1, dmic fifo fifo overrun pending interrupt */
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_FIFOCR register(0X1C)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_TRG_LEVEL_SHIFT                        (0)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_TRG_LEVEL_MASK                         (0xFFU << DMIC_FIFOCR_TRG_LEVEL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_TRG_LEVEL(n)                           ((n) << DMIC_FIFOCR_TRG_LEVEL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_SAMPLE_RES_SHIFT                       (8)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_SAMPLE_RES_MASK 	                   (0x1U << DMIC_FIFOCR_SAMPLE_RES_SHIFT)
Hal_dmic.h (include\driver\chip):	 DMIC_RES16BIT = (0X0U << DMIC_FIFOCR_SAMPLE_RES_SHIFT),
Hal_dmic.h (include\driver\chip):	 DMIC_RES24BIT = (0X1U << DMIC_FIFOCR_SAMPLE_RES_SHIFT),
Hal_dmic.h (include\driver\chip):} DMIC_FifoSampleRes;
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_MODE_SHIFT                             (9)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_MODE_MASK                              (0x1U << DMIC_FIFOCR_MODE_SHIFT)
Hal_dmic.h (include\driver\chip):	 DMIC_FIFOCR_MODE0 = (0X0U << DMIC_FIFOCR_MODE_SHIFT),
Hal_dmic.h (include\driver\chip):	 DMIC_FIFOCR_MODE1 = (0X1U << DMIC_FIFOCR_MODE_SHIFT),
Hal_dmic.h (include\driver\chip):} DMIC_FifoMode;
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOCR_FIFO_FLUSH_BIT                          HAL_BIT(31)      /* bit31, dmic fifo flush */
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_FIFOSR register (0x20)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOSR_DATA_CNT_SHIFT                         (0)
Hal_dmic.h (include\driver\chip):#define DMIC_FIFOSR_DATA_CNT_MASK                          (0xFFU << DMIC_FIFOSR_DATA_CNT_SHIFT)       /* bit0:bit7, FIFO available sample world counter */
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_CNR register
Hal_dmic.h (include\driver\chip):#define DMIC_CH_NUM_SHIFT                                  (0)
Hal_dmic.h (include\driver\chip):#define DMIC_CH_NUM_MASK                                   (0X7U << DMIC_CH_NUM_SHIFT)
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM1 = (0X0U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM2 = (0X1U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM3 = (0X2U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM4 = (0X3U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM5 = (0X4U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM6 = (0X5U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM7 = (0X6U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):	DMIC_CH_NUM8 = (0X7U << DMIC_CH_NUM_SHIFT),
Hal_dmic.h (include\driver\chip):} DMIC_ChannelNum;
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_CMR register(0x28)
Hal_dmic.h (include\driver\chip):#define DMIC_CMR_CH0_MAP_SHIFT                             (0)
Hal_dmic.h (include\driver\chip):#define DMIC_CMR_CH0_MAP_MASK(m)                           (0X7U << 4*m)
Hal_dmic.h (include\driver\chip):#define DMIC_CMR_CH0_MAP(m)                                (m << 4*m)
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_VCR0 register (0X0030)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA0R_VOL_SHIFT                              (0)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA0R_VOL_MASK                               (0xFFU << DMIC_DATA0R_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA0R_VOL(n)                                 (n << DMIC_DATA0R_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA0L_VOL_SHIFT                              (8)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA0L_VOL_MASK                               (0xFFU << DMIC_DATA0L_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA0L_VOL(n)                                 (n << DMIC_DATA0L_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA1R_VOL_SHIFT                              (16)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA1R_VOL_MASK                               (0xFFU << DMIC_DATA1R_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA1L_VOL_SHIFT                              (24)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA1L_VOL_MASK                               (0xFFU << DMIC_DATA1L_VOL_SHIFT)
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_VCR1 register (0X0034)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA2R_VOL_SHIFT                               (0)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA2R_VOL_MASK                                (0xFFU << DMIC_DATA2R_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA2L_VOL_SHIFT                               (8)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA2L_VOL_MASK                                (0xFFU << DMIC_DATA2L_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA3R_VOL_SHIFT                               (16)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA3R_VOL_MASK                                (0xFFU << DMIC_DATA3R_VOL_SHIFT)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA3L_VOL_SHIFT                               (24)
Hal_dmic.h (include\driver\chip):#define DMIC_DATA3L_VOL_MASK                                (0xFFU << DMIC_DATA3L_VOL_SHIFT)
Hal_dmic.h (include\driver\chip): * Bits definition for DMIC_HPFECR register (0X0038)
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA0_CHL_EN_BIT                           HAL_BIT(0)       /* bit0, data0 left channel enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA0_CHR_EN_BIT                           HAL_BIT(1)       /* bit1, data0 right channel 1 enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA1_CHL_EN_BIT                           HAL_BIT(2)       /* bit2, data1 left channel enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA1_CHR_EN_BIT                           HAL_BIT(3)       /* bit3, data1 right channel 1 enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA2_CHL_EN_BIT                           HAL_BIT(4)       /* bit4, data2 left channel enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA2_CHR_EN_BIT                           HAL_BIT(5)       /* bit5, data2 right channel 1 enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA3_CHL_EN_BIT                           HAL_BIT(6)       /* bit6, data3 left channel enable */
Hal_dmic.h (include\driver\chip):#define DMIC_HPF_DATA3_CHR_EN_BIT                           HAL_BIT(7)       /* bit7, data3 right channel 1 enable */
Hal_dmic.h (include\driver\chip):  * @brief Dmic low level hardware init structure definition
Hal_dmic.h (include\driver\chip):	DMIC_CtrlDmicFDT  delayTime;    /*!< Specifies dmic fdt delay time.    */
Hal_dmic.h (include\driver\chip):	DMIC_FifoMode     fifoMode;     /*!< Specifies dmic fifo mode.    */
Hal_dmic.h (include\driver\chip):	uint32_t          triggerLevel; /*!< Specifies the threshold for dmic fifo triggers.    */
Hal_dmic.h (include\driver\chip):	uint32_t          volumeGain;   /*!< Specifies the dmic hardware gain.    */
Hal_dmic.h (include\driver\chip):} DMIC_HWParam;
Hal_dmic.h (include\driver\chip):  * @brief Dmic data format init structure definition
Hal_dmic.h (include\driver\chip):	DMIC_SampleRate    sampleRate;  /*!< Specifies the sampling rate of the stream.    */
Hal_dmic.h (include\driver\chip):	DMIC_FifoSampleRes resolution;  /*!< Specifies the sampling accuracy of the stream.    */
Hal_dmic.h (include\driver\chip):} DMIC_DataParam;
Hal_dmic.h (include\driver\chip):  * @brief Dmic module init structure definition
Hal_dmic.h (include\driver\chip):	const DMIC_HWParam  *hwParam; /*!< Dmic hardware init structure.    */
Hal_dmic.h (include\driver\chip):} DMIC_Param;
Hal_dmic.h (include\driver\chip):HAL_Status HAL_DMIC_Init(DMIC_Param *param);
Hal_dmic.h (include\driver\chip):void HAL_DMIC_DeInit();
Hal_dmic.h (include\driver\chip):HAL_Status HAL_DMIC_Open(DMIC_DataParam *param);
Hal_dmic.h (include\driver\chip):void HAL_DMIC_Close();
Hal_dmic.h (include\driver\chip):HAL_Status HAL_DMIC_Suspend();
Hal_dmic.h (include\driver\chip):HAL_Status HAL_DMIC_Resume();
Hal_dmic.h (include\driver\chip):int32_t HAL_DMIC_Read_DMA(uint8_t *buf, uint32_t size);
Hal_dmic.h (include\driver\chip):#endif /* _DRIVER_CHIP_HAL_DMIC_H_ */
Hal_gpio.h (include\driver\chip):    GPIOA_P10_F4_DMIC_CLK   = 4U,
Hal_gpio.h (include\driver\chip):    GPIOA_P11_F4_DMIC_DATA  = 4U,
Hal_gpio.h (include\driver\chip):    GPIOA_P21_F3_DMIC_CLK   = 3U,
Hal_gpio.h (include\driver\chip):    GPIOA_P22_F3_DMIC_DATA  = 3U,
Hal_gpio.h (include\driver\chip):    GPIOA_P10_F4_DMIC_CLK   = 4U,
Hal_gpio.h (include\driver\chip):    GPIOA_P11_F4_DMIC_DATA  = 4U,
Hal_gpio.h (include\driver\chip):    GPIOA_P21_F3_DMIC_CLK   = 3U,
Hal_gpio.h (include\driver\chip):    GPIOA_P22_F3_DMIC_DATA  = 3U,
Hal_gpio.h (include\driver\chip):    GPIOB_P14_F4_DMIC_CLK   = 4U,
Hal_gpio.h (include\driver\chip):    GPIOB_P15_F4_DMIC_DATA  = 4U,
Hal_snd_card.c (src\driver\chip\codec):#define SND_CARD_DEFAULT_RECORD_DEV			AUDIO_IN_DEV_AMIC
Hal_snd_card.c (src\driver\chip\codec):					if(sound_card->codec_drv->dai_ops->set_volume && route_dev != AUDIO_IN_DEV_DMIC){
Hal_snd_card.h (include\driver\chip):	XRADIO_PLATFORM_DMIC,
Hal_snd_card.h (include\driver\chip):	AUDIO_IN_DEV_AMIC	= HAL_BIT(AUDIO_IN_DEV_SHIFT),		/*< AMIC > */
Hal_snd_card.h (include\driver\chip):	AUDIO_IN_DEV_DMIC 	= HAL_BIT(AUDIO_IN_DEV_SHIFT + 2),	/*< DMIC > */
Hal_util.c (src\driver\chip): * @brief Provide accurate delay (in microsecond), and its accuracy is about
Hal_util.c (src\driver\chip): *        32 microseconds.
Hal_util.c (src\driver\chip): * @param[in] us Time (in microsecond) to delay
Handlers.c (src\net\libwebsockets\plugins\generic-sessions):/* support dynamic username / email checking */
Hpack.c (src\net\libwebsockets\lib\http2): * dynamic table
Hpack.c (src\net\libwebsockets\lib\http2): * returns 0 if dynamic entry (arg and len are filled)
Hpack.c (src\net\libwebsockets\lib\http2):	struct hpack_dynamic_table *dyn;
Hpack.c (src\net\libwebsockets\lib\http2):	/* dynamic table only belongs to network wsi */
Hpack.c (src\net\libwebsockets\lib\http2):		lwsl_notice("no dynamic table\n");
Hpack.c (src\net\libwebsockets\lib\http2):lws_h2_dynamic_table_dump(struct lws *wsi)
Hpack.c (src\net\libwebsockets\lib\http2):	struct hpack_dynamic_table *dyn;
Hpack.c (src\net\libwebsockets\lib\http2):lws_dynamic_free(struct hpack_dynamic_table *dyn, int idx)
Hpack.c (src\net\libwebsockets\lib\http2):lws_dynamic_token_insert(struct lws *wsi, int hdr_len,
Hpack.c (src\net\libwebsockets\lib\http2):	struct hpack_dynamic_table *dyn;
Hpack.c (src\net\libwebsockets\lib\http2):	/* dynamic table only belongs to network wsi */
Hpack.c (src\net\libwebsockets\lib\http2):	lws_h2_dynamic_table_dump(wsi);
Hpack.c (src\net\libwebsockets\lib\http2):		lws_dynamic_free(dyn, new_index);
Hpack.c (src\net\libwebsockets\lib\http2):		lws_dynamic_free(dyn, n);
Hpack.c (src\net\libwebsockets\lib\http2):	lws_h2_dynamic_table_dump(wsi);
Hpack.c (src\net\libwebsockets\lib\http2):lws_hpack_dynamic_size(struct lws *wsi, int size)
Hpack.c (src\net\libwebsockets\lib\http2):	struct hpack_dynamic_table *dyn;
Hpack.c (src\net\libwebsockets\lib\http2):	 * linear buffer containing dynamic header names and values... when it
Hpack.c (src\net\libwebsockets\lib\http2):	dte = lws_zalloc(sizeof(*dte) * (size + 1), "dynamic table entries");
Hpack.c (src\net\libwebsockets\lib\http2):		lws_dynamic_free(dyn, n);
Hpack.c (src\net\libwebsockets\lib\http2):	lws_h2_dynamic_table_dump(wsi);
Hpack.c (src\net\libwebsockets\lib\http2):lws_hpack_destroy_dynamic_header(struct lws *wsi)
Hpack.c (src\net\libwebsockets\lib\http2):	struct hpack_dynamic_table *dyn;
Hpack.c (src\net\libwebsockets\lib\http2):		/* dynamic result */
Hpack.c (src\net\libwebsockets\lib\http2):			lws_h2_dynamic_table_dump(wsi);
Hpack.c (src\net\libwebsockets\lib\http2):			if (lws_hpack_dynamic_size(wsi, h2n->hpack_len))
Hpack.c (src\net\libwebsockets\lib\http2):			if (lws_hpack_dynamic_size(wsi, h2n->hpack_len))
Hpack.c (src\net\libwebsockets\lib\http2):			 * mark us as having been set at the time of dynamic
Hpack.c (src\net\libwebsockets\lib\http2):			if (lws_dynamic_token_insert(wsi, h2n->hpack_hdr_len, m,
HTTPClient.c (src\net\httpclient\api):// Author:	Eitan Michaelson
HTTPClient.c (src\net\httpclient\api):        UINT32         nAllocationSize;             // Size of the dynamically allocated buffer
HTTPClient.c (src\net\httpclient\api):        UINT32         nAllocationSize;             // Size of the dynamically allocated buffer
HTTPClient.c (src\net\httpclient\api):        HTTP_PARAM  HttpParamOpq,HttpParamRealm,HttpParamNonce,HttpParamQop,HttpParamAlg;     // Pointers and lengths of the dynamic sections
HTTPClient.c (src\net\httpclient\api):// Author Name	: Eitan Michaelson
HTTPClient.h (include\net\httpclient\api):#define HTTP_CLIENT_MEMORY_RESIZABLE        TRUE        // Permission to dynamically resize the headers buffer
HTTPClientCommon.h (include\net\httpclient\api):// Author:	Eitan Michaelso
HTTPClientSample.c (src\net\httpclient\sample):// Author:	 Eitan Michaelson
HTTPClientWrapper.c (src\net\httpclient\api):// Author Name	: Eitan Michaelson
HTTPClientWrapper.h (include\net\httpclient\api):// Section      : Microsoft Windows Support
HTTPClientWrapper.h (include\net\httpclient\api):// Kluge alert: redefining strncasecmp() as memicmp() for Windows.
HTTPClientWrapper.h (include\net\httpclient\api):#define		strncasecmp			memicmp
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd): * each file stored in the file system.  By defining LWIP_HTTPD_DYNAMIC_HEADERS in
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):/* The dynamically generated Content-Length buffer needs space for CRLF + NULL */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):/* The dynamically generated Content-Length buffer shall be able to work with
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_FILE_READ
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd): * Also frees the file data if dynamic.
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_FILE_READ
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd): * Also frees the file data if dynamic.
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):/** Sub-function of http_send(): send dynamic headers
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_FILE_READ
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_FILE_READ
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#else /* LWIP_HTTPD_DYNAMIC_FILE_READ */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):  LWIP_ASSERT("SSI and DYNAMIC_HEADERS turned off but eof not reached", 0);
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_SSI || LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if !LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* !LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#else /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd.c (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Httpd_opts.h (include\net\lwip-2.0.3\lwip\apps):#if !defined LWIP_HTTPD_DYNAMIC_HEADERS || defined __DOXYGEN__
Httpd_opts.h (include\net\lwip-2.0.3\lwip\apps):#define LWIP_HTTPD_DYNAMIC_HEADERS 0
Httpd_opts.h (include\net\lwip-2.0.3\lwip\apps):/** Set this to 1 to support fs_read() to dynamically read file data.
Httpd_opts.h (include\net\lwip-2.0.3\lwip\apps):#if !defined LWIP_HTTPD_DYNAMIC_FILE_READ || defined __DOXYGEN__
Httpd_opts.h (include\net\lwip-2.0.3\lwip\apps):#define LWIP_HTTPD_DYNAMIC_FILE_READ  0
Httpd_structs.h (src\net\lwip-2.0.3\src\apps\httpd):#if LWIP_HTTPD_DYNAMIC_HEADERS
Httpd_structs.h (src\net\lwip-2.0.3\src\apps\httpd):#endif /* LWIP_HTTPD_DYNAMIC_HEADERS */
Index.html (src\net\libwebsockets\plugins\generic-sessions\assets):	for dynamic events and easy to maintain.
Init.c (src\net\lwip-1.4.1\src\core):#if (DNS_LOCAL_HOSTLIST && !DNS_LOCAL_HOSTLIST_IS_DYNAMIC && !(defined(DNS_LOCAL_HOSTLIST_INIT)))
Init.c (src\net\lwip-2.0.3\src\core):#if (DNS_LOCAL_HOSTLIST && !DNS_LOCAL_HOSTLIST_IS_DYNAMIC && !(defined(DNS_LOCAL_HOSTLIST_INIT)))
Ipcp.c (src\net\lwip-1.4.1\src\netif\ppp):        /* Microsoft primary or secondary DNS request */
Ipcp.c (src\net\lwip-1.4.1\src\netif\ppp):        /* Microsoft primary or secondary WINS request */
Ipcp.c (src\net\lwip-2.0.3\src\netif\ppp):	    /* Microsoft primary or secondary DNS request */
Ipcp.c (src\net\lwip-2.0.3\src\netif\ppp):	    /* Microsoft primary or secondary WINS request */
Karaok.c (project\example\audio_reverb):	audio_manager_handler(AUDIO_SND_CARD_DEFAULT, AUDIO_MANAGER_SET_VOLUME_LEVEL, AUDIO_IN_DEV_AMIC, 3);
Kfifo.h (project\example\audio_play): * define compatibility "struct kfifo" for dynamic allocated fifos
Kfifo.h (project\example\audio_play): * kfifo_alloc - dynamically allocates a new fifo buffer
Kfifo.h (project\example\audio_play): * This macro dynamically allocates a new fifo buffer.
Lcp.c (src\net\lwip-1.4.1\src\netif\ppp):              && cichar != CHAP_MICROSOFT
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):        ao->chap_mdtype &= ~MDTYPE_MICROSOFT;
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):        ao->chap_mdtype &= ~MDTYPE_MICROSOFT_V2;
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):          wo->chap_mdtype |= MDTYPE_MICROSOFT;
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):          wo->chap_mdtype |= MDTYPE_MICROSOFT_V2;
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):    PPPDEBUG(LOG_DEBUG, (" CHAP_MS=%d CHAP_MS2=%d", !!(ao->chap_mdtype&MDTYPE_MICROSOFT), !!(ao->chap_mdtype&MDTYPE_MICROSOFT_V2)));
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):			    case CHAP_MICROSOFT:
Lcp.c (src\net\lwip-2.0.3\src\netif\ppp):			    case CHAP_MICROSOFT_V2:
Libwebsockets.c (src\net\libwebsockets\lib):		lws_hpack_destroy_dynamic_header(wsi);
Libwebsockets.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_API_CLOSE, 1);
Libwebsockets.c (src\net\libwebsockets\lib):	u = time_in_microseconds();
Libwebsockets.c (src\net\libwebsockets\lib):		now = time_in_microseconds() / 100;
Libwebsockets.c (src\net\libwebsockets\lib):lws_stats_atomic_bump(struct lws_context * context,
Libwebsockets.c (src\net\libwebsockets\lib):lws_stats_atomic_max(struct lws_context * context,
Libwebsockets.h (include\net\libwebsockets): *	images or whatever over http and dynamic data over websockets all in
Libwebsockets.h (include\net\libwebsockets): * intermediary dynamically.
List.h (include\kernel\freertos): * functionally atomic way (within critical sections of with the scheduler
Lwipopts.h (include\net\lwip-1.4.1): * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
Lwipopts.h (include\net\lwip-1.4.1):/** If this is turned on, the local host-list can be dynamically changed
Lwipopts.h (include\net\lwip-1.4.1):#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
Lwipopts.h (include\net\lwip-2.0.3): * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
Lwipopts.h (include\net\lwip-2.0.3):/** If this is turned on, the local host-list can be dynamically changed
Lwipopts.h (include\net\lwip-2.0.3):#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
Lws-plat-esp32.c (src\net\libwebsockets\lib\plat):unsigned long long time_in_microseconds(void)
Lws-plat-esp32.c (src\net\libwebsockets\lib\plat):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_SERVICE_ENTRY, 1);
Lws-plat-esp32.c (src\net\libwebsockets\lib\plat):	uint64_t now = time_in_microseconds();
Lws-plat-esp32.c (src\net\libwebsockets\lib\plat):	lws_esp32.genled_t = time_in_microseconds();
Lws-plat-esp32.c (src\net\libwebsockets\lib\plat):	r = time_in_microseconds();
Lws-plat-esp8266.c (src\net\libwebsockets\lib\plat):unsigned long long time_in_microseconds(void)
Lws-plat-esp8266.c (src\net\libwebsockets\lib\plat):	unsigned long long t = time_in_microseconds();
Lws-plat-esp8266.c (src\net\libwebsockets\lib\plat):	unsigned long long t = time_in_microseconds();
Lws-plat-optee.c (src\net\libwebsockets\lib\plat):unsigned long long time_in_microseconds(void)
Lws-plat-unix.c (src\net\libwebsockets\lib\plat):unsigned long long time_in_microseconds(void)
Lws-plat-unix.c (src\net\libwebsockets\lib\plat):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_SERVICE_ENTRY, 1);
Lws-plat-win.c (src\net\libwebsockets\lib\plat):time_in_microseconds()
Lws-plat-win.c (src\net\libwebsockets\lib\plat):#ifndef DELTA_EPOCH_IN_MICROSECS
Lws-plat-win.c (src\net\libwebsockets\lib\plat):#define DELTA_EPOCH_IN_MICROSECS 11644473600000000ULL
Lws-plat-win.c (src\net\libwebsockets\lib\plat):	return (datetime.QuadPart - DELTA_EPOCH_IN_MICROSECS) / 10;
Lws-plat-win.c (src\net\libwebsockets\lib\plat):	time_t ret = time_in_microseconds() / 1000000;
Lws-plat-xr871.c (src\net\libwebsockets\lib\plat):unsigned long long time_in_microseconds(void)
Lws-plat-xr871.c (src\net\libwebsockets\lib\plat):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_SERVICE_ENTRY, 1);
LwsService.cpp (src\net\libwebsockets\test-apps\android\app\src\main\jni):// Code executed when loading the dynamic link library //
Main.c (project\example\audio_record):	audio_manager_handler(AUDIO_SND_CARD_DEFAULT, AUDIO_MANAGER_SET_VOLUME_LEVEL, AUDIO_IN_DEV_AMIC, 3);
Main.c (project\example\audio_reverb):	microphone_detect_start();
Main.c (project\example\dma): *	[DMA_PERIPH_DMIC],
Main.c (project\example\rtc): * @brief Read the time value (in microsecond) of the RTC's Free running counter
Makefile (src\net\mbedtls-2.16.0\library):# MicroBlaze specific options:
Makefile (src\net\mbedtls-2.16.0\library):	$(CC) -dynamiclib -L. -lmbedcrypto -lmbedx509 $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_TLS)
Makefile (src\net\mbedtls-2.16.0\library):	$(CC) -dynamiclib -L. -lmbedcrypto  $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_X509)
Makefile (src\net\mbedtls-2.16.0\library):	$(CC) -dynamiclib $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_CRYPTO)
Makefsdata.c (src\net\lwip-2.0.3\src\apps\httpd\makefsdata):#define LWIP_HTTPD_DYNAMIC_HEADERS 1
Mbedtls.h (include\net\mbedtls-2.16.0\mbedtls): * The structure ensures that mbedtls api works properly and is dynamically created by
Mbedtls.h (include\net\mbedtls-2.2.0\mbedtls): * The structure ensures that mbedtls api works properly and is dynamically created by
Mbuf_0.h (include\sys):#define MT_DATA         1       /* dynamic (data) allocation */
Mbuf_1.h (include\sys):#define MT_DATA         1       /* dynamic (data) allocation */
Mdns.c (src\net\lwip-2.0.3\src\apps\mdns): * - Dynamic size of outgoing packet
Mdns.c (src\net\lwip-2.0.3\src\apps\mdns): *               allow dynamic replies.
Mdns.txt (src\net\lwip-2.0.3\doc):The MDNS code puts its structs on the stack where suitable to reduce dynamic
Mem.c (src\net\lwip-1.4.1\src\core): * Dynamic memory manager
Mem.c (src\net\lwip-2.0.3\src\core): * Dynamic memory manager
Memp.c (src\net\lwip-1.4.1\src\core): * Dynamic pool memory manager
Memp.c (src\net\lwip-2.0.3\src\core): * Dynamic pool memory manager
Memp_std.h (include\net\lwip-1.4.1\lwip):#if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Memp_std.h (include\net\lwip-1.4.1\lwip):#endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Memp_std.h (include\net\lwip-2.0.3\lwip\priv):#if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Memp_std.h (include\net\lwip-2.0.3\lwip\priv):#endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Mib2.c (src\net\lwip-1.4.1\src\core\snmp):          /* dynamic (?) */
Mqtt_client.txt (src\net\lwip-2.0.3\doc):Dynamic allocation:
Msg_in.c (src\net\lwip-1.4.1\src\core\snmp):  /* set all values "atomically" (be as "atomic" as possible) */
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_X86_OPENSSL_CONFIG := no-asm no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_X86_64_OPENSSL_CONFIG := no-asm no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp enable-ec_nistp_64_gcc_128
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_ARM_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_ARM_V7A_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_ARM_V7A_HARD_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_ARM64_V8A_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_MIPS_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
NativeLibs.mk (src\net\libwebsockets\test-apps\android\app\src\main\jni):TARGET_MIPS64_OPENSSL_CONFIG := no-shared no-idea no-mdc2 no-rc5 no-zlib no-zlib-dynamic enable-tlsext no-ssl2 no-ssl3 enable-ec enable-ecdh enable-ecp
Net.h (include\net\mbedtls-2.2.0\mbedtls): * \param usec     Amount of microseconds to sleep
Net_sockets.h (include\net\mbedtls-2.16.0\mbedtls): *              * Microsoft Windows and Windows CE
Net_sockets.h (include\net\mbedtls-2.16.0\mbedtls): * \param usec     Amount of microseconds to sleep
Net_sockets.h (src\net\mbedtls-2.16.0\include\mbedtls): *              * Microsoft Windows and Windows CE
Net_sockets.h (src\net\mbedtls-2.16.0\include\mbedtls): * \param usec     Amount of microseconds to sleep
Nopoll-0.2.4.txt (src\net\nopoll\doc\release-notes):* [fix] Updated nopoll_conn to implement a micro pause after each
Nopoll.c (src\net\nopoll\src): * @param microseconds The amount of time to wait.
Nopoll.c (src\net\nopoll\src):void        nopoll_sleep (long microseconds)
Nopoll.c (src\net\nopoll\src):	usleep (microseconds);
Nopoll.c (src\net\nopoll\src):	Sleep (microseconds / 1000);
Nopoll.c (src\net\nopoll\src):	microseconds = microseconds < 1000 ? 1000 : microseconds;
Nopoll.c (src\net\nopoll\src):	OS_MSleep(microseconds / 1000);
Nopoll.c (src\net\nopoll\src): * allowed option is dynamic linking (so final user is capable of
Nopoll.c (src\net\nopoll\src): * updating that dynamic linked part) or a practical procedure where
Nopoll.h (include\net\nopoll):void        nopoll_sleep (long microseconds);
Nopoll_conn.c (src\net\nopoll\src): * microseconds (1 second = 1000000 microseconds). If a null value is
Nopoll_conn.c (src\net\nopoll\src): * @param microseconds_to_wait Timeout value to be used. The value
Nopoll_conn.c (src\net\nopoll\src): * provided is measured in microseconds. Use 0 to restore the connect
Nopoll_conn.c (src\net\nopoll\src):						long        microseconds_to_wait)
Nopoll_conn.c (src\net\nopoll\src):	ctx->conn_connect_std_timeout = microseconds_to_wait;
Nopoll_conn.h (include\net\nopoll):						long        microseconds_to_wait);
Opt.h (include\net\lwip-1.4.1\lwip): * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
Opt.h (include\net\lwip-1.4.1\lwip):/** If this is turned on, the local host-list can be dynamically changed
Opt.h (include\net\lwip-1.4.1\lwip):#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
Opt.h (include\net\lwip-1.4.1\lwip):#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
Opt.h (include\net\lwip-1.4.1\lwip):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Opt.h (include\net\lwip-2.0.3\lwip): * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
Opt.h (include\net\lwip-2.0.3\lwip):/** If this is turned on, the local host-list can be dynamically changed
Opt.h (include\net\lwip-2.0.3\lwip):#if !defined DNS_LOCAL_HOSTLIST_IS_DYNAMIC || defined __DOXYGEN__
Opt.h (include\net\lwip-2.0.3\lwip):#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
Opt.h (include\net\lwip-2.0.3\lwip):#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
Os_time.h (include\kernel\os\freertos):#define OS_USEC_PER_MSEC    1000U       /* microseconds per millisecond */
Os_time.h (include\kernel\os\freertos):#define OS_USEC_PER_SEC     1000000U    /* microseconds per second */
Os_time.h (include\kernel\os\freertos):/* microseconds per OS tick (1000000 / OS_HZ) */
Os_time.h (include\kernel\os\freertos):/* Due to portTICK_TYPE_IS_ATOMIC is 1, calling xTaskGetTickCount() in ISR is
Output.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_API_WRITE, 1);
Output.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_WRITE_PARTIALS, 1);
Output.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_B_PARTIALS_ACCEPTED_PARTS, n);
Output.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_API_LWS_WRITE, 1);
Output.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_B_WRITE, len);
Output.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_API_READ, 1);
Output.c (src\net\libwebsockets\lib):		lws_stats_atomic_bump(context, pt, LWSSTATS_B_READ, n);
Parsers.c (src\net\libwebsockets\lib\server):			lws_stats_atomic_bump(wsi->context, pt,
Parsers.c (src\net\libwebsockets\lib\server):				lws_stats_atomic_bump(context, pt,
Pbuf.c (src\net\lwip-1.4.1\src\core): * Packets are built from the pbuf data structure. It supports dynamic
Pbuf.c (src\net\lwip-1.4.1\src\core): *             changed. Memory which is dynamic should generally not
Pbuf.c (src\net\lwip-2.0.3\src\core): * Packets are built from the pbuf data structure. It supports dynamic
Pbuf.c (src\net\lwip-2.0.3\src\core): *             changed. Memory which is dynamic should generally not
Platform.h (include\net\mbedtls-2.16.0\mbedtls): *        dynamically configured at runtime.
Platform.h (include\net\mbedtls-2.16.0\mbedtls): * \brief               This function dynamically sets the memory-management
Platform.h (include\net\mbedtls-2.16.0\mbedtls): * \brief                This function dynamically configures the fprintf
Platform.h (include\net\mbedtls-2.16.0\mbedtls): * \brief               This function dynamically configures the snprintf
Platform.h (include\net\mbedtls-2.16.0\mbedtls): * \brief             This function dynamically configures the exit
Platform.h (src\net\mbedtls-2.16.0\include\mbedtls): *        dynamically configured at runtime.
Platform.h (src\net\mbedtls-2.16.0\include\mbedtls): * \brief               This function dynamically sets the memory-management
Platform.h (src\net\mbedtls-2.16.0\include\mbedtls): * \brief                This function dynamically configures the fprintf
Platform.h (src\net\mbedtls-2.16.0\include\mbedtls): * \brief               This function dynamically configures the snprintf
Platform.h (src\net\mbedtls-2.16.0\include\mbedtls): * \brief             This function dynamically configures the exit
Player_app.c (project\common\apps):#include "util/atomic.h"
Pollfd.c (src\net\libwebsockets\lib):			wsi->active_writable_req_us = time_in_microseconds();
Pollfd.c (src\net\libwebsockets\lib):			lws_stats_atomic_bump(wsi->context, pt,
Pollfd.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_WRITEABLE_CB_REQ, 1);
Pollfd.c (src\net\libwebsockets\lib):		wsi->active_writable_req_us = time_in_microseconds();
Pollfd.c (src\net\libwebsockets\lib):		lws_stats_atomic_bump(wsi->context, pt,
Portmacro.h (include\kernel\freertos\portable\gcc\arm_cm3):	#define portTICK_TYPE_IS_ATOMIC 1
Portmacro.h (include\kernel\freertos\portable\gcc\arm_cm4f):	#define portTICK_TYPE_IS_ATOMIC 1
Ppp.h (include\net\lwip-2.0.3\netif\ppp):  unsigned int require_mppe         :1;      /* Require MPPE (Microsoft Point to Point Encryption) */
Ppp.h (include\net\lwip-2.0.3\netif\ppp):/* Disable MPPE (Microsoft Point to Point Encryption). This parameter is exclusive. */
Ppp.h (include\net\lwip-2.0.3\netif\ppp):/* Require the use of MPPE (Microsoft Point to Point Encryption). */
Ppp.txt (src\net\lwip-2.0.3\doc):* MSCHAPv1, Microsoft version of CHAP, version 1
Ppp.txt (src\net\lwip-2.0.3\doc):* MSCHAPv2, Microsoft version of CHAP, version 2
Ppp.txt (src\net\lwip-2.0.3\doc):* MPPE, Microsoft Point-to-Point Encryption
Ppp.txt (src\net\lwip-2.0.3\doc):tries to mimic what we usually see on xDSL modems while they are negotiating
Ppp_impl.h (include\net\lwip-2.0.3\netif\ppp):#define CHAP_MDTYPE_SUPPORTED (MDTYPE_MICROSOFT_V2 | MDTYPE_MICROSOFT | MDTYPE_MD5)
Private-libwebsockets.h (include\net\libwebsockets):struct hpack_dynamic_table {
Private-libwebsockets.h (include\net\libwebsockets):	struct hpack_dynamic_table hpack_dyn_table;
Private-libwebsockets.h (include\net\libwebsockets):lws_hpack_destroy_dynamic_header(struct lws *wsi);
Private-libwebsockets.h (include\net\libwebsockets):lws_hpack_dynamic_size(struct lws *wsi, int size);
Private-libwebsockets.h (include\net\libwebsockets):time_in_microseconds(void);
Private-libwebsockets.h (include\net\libwebsockets):lws_stats_atomic_bump(struct lws_context * context,
Private-libwebsockets.h (include\net\libwebsockets):lws_stats_atomic_max(struct lws_context * context,
Private-libwebsockets.h (include\net\libwebsockets):static inline uint64_t lws_stats_atomic_bump(struct lws_context * context,
Private-libwebsockets.h (include\net\libwebsockets):static inline uint64_t lws_stats_atomic_max(struct lws_context * context,
Prj_config.h (project\example\ytasr):/* sound card1 (internal dmic) enable/disable */
Publisher.c (project\common\framework\sys_ctrl):static void atomic_set(int *var, uint32_t cnt)
Publisher.c (project\common\framework\sys_ctrl):		atomic_set(&obs->state, OBSERVER_DETACHED);
Publisher.c (project\common\framework\sys_ctrl):	atomic_set(&base->state, PUBLISHER_WORKING);
Publisher.c (project\common\framework\sys_ctrl):			atomic_set(&itor->state, OBSERVER_ILDE);
Publisher.c (project\common\framework\sys_ctrl):	atomic_set(&base->state, PUBLISHER_IDLE);
Publisher.h (project\common\framework\sys_ctrl):	OS_Mutex_t lock;	// or uint32_t sync by atomic;
Rawapi.txt (src\net\lwip-1.4.1\doc):  Initializes the dynamic memory heap defined by MEM_SIZE.
Readme.txt (src\kernel\freertos\source):specific to a particular microcontroller and or compiler.
Readme.txt (src\kernel\freertos\source):a particular microcontroller and or compiler.
Readme.txt (src\kernel\freertos\source\portable):specific to a particular microcontroller and/or compiler.
Readme.txt (src\kernel\freertos\source\portable):microcontroller or compiler.
Readme.txt (src\kernel\freertos\source\portable):microcontroller then the port specific files are contained in
Readme.txt (src\net\httpclient): Author: Eitan Michaelson: noyasoft@gmail.com
Readme.txt (src\net\httpclient): Copyright (c) 2006 Eitan Michaelson
Recorder_app.c (project\common\apps):#include "util/atomic.h"
Retarget.c (project\common\startup\gcc):/* Dynamic memory allocation related syscall. */
Rfc6455.txt (src\net\nopoll\doc):   server dynamically selecting which subprotocol to use based on the
Rfc6455.txt (src\net\nopoll\doc):   specification to provide a generic mechanism for dynamic author-
Rsa.c (src\net\mbedtls-2.16.0\library): *      Michael Schwarz, Samuel Weiser, Daniel Gruss, Clémentine Maurice and
Run-test-suites.pl (src\net\mbedtls-2.2.0\tests\scripts):# in case test suites are linked dynamically
Sdmmc_diskio.c (src\fs\fatfs\driver):/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
Server.c (src\net\libwebsockets\lib\server):	 * https://msdn.microsoft.com/zh-tw/library/
Server.c (src\net\libwebsockets\lib\server):		lws_hpack_dynamic_size(wsi, wsi->h2.h2n->set.s[
Server.c (src\net\libwebsockets\lib\server):			lws_stats_atomic_bump(context, &context->pt[0],
Server.c (src\net\libwebsockets\lib\server):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_CONNECTIONS, 1);
Server.c (src\net\libwebsockets\lib\server):			lws_stats_atomic_bump(wsi->context, pt,
Server.c (src\net\libwebsockets\lib\server):				uint64_t ul = time_in_microseconds() -
Server.c (src\net\libwebsockets\lib\server):				lws_stats_atomic_bump(wsi->context, pt,
Server.c (src\net\libwebsockets\lib\server):				lws_stats_atomic_max(wsi->context, pt,
Server.c (src\net\libwebsockets\lib\server):			lws_stats_atomic_bump(wsi->context, pt,
Server.c (src\net\libwebsockets\lib\server):				uint64_t ul = time_in_microseconds() -
Server.c (src\net\libwebsockets\lib\server):				lws_stats_atomic_bump(wsi->context, pt,
Server.c (src\net\libwebsockets\lib\server):				lws_stats_atomic_max(wsi->context, pt,
Service.c (src\net\libwebsockets\lib):	lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_WRITEABLE_CB, 1);
Service.c (src\net\libwebsockets\lib):		uint64_t ul = time_in_microseconds() -
Service.c (src\net\libwebsockets\lib):		lws_stats_atomic_bump(wsi->context, pt,
Service.c (src\net\libwebsockets\lib):		lws_stats_atomic_max(wsi->context, pt,
Service.c (src\net\libwebsockets\lib):		lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_TIMEOUTS, 1);
Snmp_agent.txt (src\net\lwip-1.4.1\doc):to preserve precious RAM on small microcontrollers.
Snmp_agent.txt (src\net\lwip-1.4.1\doc):However RAM location is possible for a dynamically
Snmp_agent.txt (src\net\lwip-1.4.1\doc):turn use dynamically allocated index trees from RAM.
Snmp_mib2_ip.c (src\net\lwip-2.0.3\src\apps\snmp):    value->u32 = 3; /* dynamic*/
Sntp.c (src\net\lwip-2.0.3\src\apps\sntp):/* Configure behaviour depending on microsecond or second precision */
Sntp_opts.h (include\net\lwip-2.0.3\lwip\apps): * Define SNTP_SET_SYSTEM_TIME_US(sec, us) to set the time in microseconds instead of this one
Sockets.c (src\net\lwip-1.4.1\src\api):       We don't actually need any dynamic memory. Our entry on the
Sockets.c (src\net\lwip-2.0.3\src\api):       We don't actually need any dynamic memory. Our entry on the
Sockets.h (include\net\lwip-1.4.1\lwip):  long    tv_usec;        /* and microseconds */
Sockets.h (include\net\lwip-2.0.3\lwip):  long    tv_usec;        /* and microseconds */
Source.h (src\net\shttpd-1.42\examples):"Dynamic Power Consumption Management<br /><br />"               \
Ssl-http2.c (src\net\libwebsockets\lib\http2):	lws_hpack_dynamic_size(wsi,
Ssl-server.c (src\net\libwebsockets\lib\server):			wsi->accept_start_us = time_in_microseconds();
Ssl-server.c (src\net\libwebsockets\lib\server):		lws_stats_atomic_bump(wsi->context, pt,
Ssl-server.c (src\net\libwebsockets\lib\server):			lws_stats_atomic_bump(wsi->context, pt,
Ssl-server.c (src\net\libwebsockets\lib\server):		lws_stats_atomic_bump(wsi->context, pt,
Ssl-server.c (src\net\libwebsockets\lib\server):		lws_stats_atomic_bump(wsi->context, pt,
Ssl-server.c (src\net\libwebsockets\lib\server):				      time_in_microseconds() - wsi->accept_start_us);
Ssl-server.c (src\net\libwebsockets\lib\server):		wsi->accept_start_us = time_in_microseconds();
Ssl.c (src\net\libwebsockets\lib\tls\mbedtls):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_API_READ, 1);
Ssl.c (src\net\libwebsockets\lib\tls\mbedtls):                lws_stats_atomic_bump(wsi->context, pt,
Ssl.c (src\net\libwebsockets\lib\tls\mbedtls):				time_in_microseconds() - wsi->accept_start_us);
Ssl.c (src\net\libwebsockets\lib\tls\mbedtls):                lws_stats_atomic_bump(wsi->context, pt,
Ssl.c (src\net\libwebsockets\lib\tls\mbedtls):	lws_stats_atomic_bump(context, pt, LWSSTATS_B_READ, n);
Ssl.c (src\net\libwebsockets\lib\tls\openssl):	lws_stats_atomic_bump(context, pt, LWSSTATS_C_API_READ, 1);
Ssl.c (src\net\libwebsockets\lib\tls\openssl):                lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_MS_SSL_RX_DELAY,
Ssl.c (src\net\libwebsockets\lib\tls\openssl):				time_in_microseconds() - wsi->accept_start_us);
Ssl.c (src\net\libwebsockets\lib\tls\openssl):                lws_stats_atomic_bump(wsi->context, pt, LWSSTATS_C_SSL_CONNS_HAD_RX, 1);
Ssl.c (src\net\libwebsockets\lib\tls\openssl):	lws_stats_atomic_bump(context, pt, LWSSTATS_B_READ, n);
Task.h (include\kernel\freertos): * Macro to enable microcontroller interrupts.
Task.h (include\kernel\freertos): * access to the entire microcontroller memory map.  Systems that include MPU
Task.h (include\kernel\freertos): * the idle task is not starved of microcontroller processing time if your
Task.h (include\kernel\freertos): * Suspend any task.  When suspended a task will never get any microcontroller
Task.h (include\kernel\freertos):	 // The created task will once again get microcontroller processing
Task.h (include\kernel\freertos):		 // sections as we have all the microcontroller processing time.
Task.h (include\kernel\freertos):		 // sections as we have all the microcontroller processing time.
Task.h (include\kernel\freertos): * microcontroller being used or interrupt nesting is either not supported or
Tasks.c (src\kernel\freertos\source):		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
Tasks.c (src\kernel\freertos\source):	microcontroller architecture. */
Tasks.c (src\kernel\freertos\source):	performed in a way that is tailored to the particular microcontroller
Tasks.c (src\kernel\freertos\source):				/* The stack was allocated dynamically.  Note this so it can be
Tasks.c (src\kernel\freertos\source):			/* Only free the stack if it was allocated dynamically in the first
Tcp.c (src\net\lwip-1.4.1\src\core):   "The Dynamic and/or Private Ports are those from 49152 through 65535" */
Tcp.c (src\net\lwip-2.0.3\src\core):   "The Dynamic and/or Private Ports are those from 49152 through 65535" */
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#define TEST_DYNAMIC_VHOST
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#if defined(TEST_DYNAMIC_VHOST)
Test-server-v2.0.c (src\net\libwebsockets\test-apps):volatile int dynamic_vhost_enable = 0;
Test-server-v2.0.c (src\net\libwebsockets\test-apps):struct lws_vhost *dynamic_vhost;
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#if defined(TEST_DYNAMIC_VHOST)
Test-server-v2.0.c (src\net\libwebsockets\test-apps): *  to test dynamic vhost creation, fire a SIGUSR1 at the test server.
Test-server-v2.0.c (src\net\libwebsockets\test-apps):uv_timeout_dynamic_vhost_toggle(uv_timer_t *w
Test-server-v2.0.c (src\net\libwebsockets\test-apps):	if (dynamic_vhost_enable && !dynamic_vhost) {
Test-server-v2.0.c (src\net\libwebsockets\test-apps):		lwsl_notice("creating dynamic vhost...\n");
Test-server-v2.0.c (src\net\libwebsockets\test-apps):		dynamic_vhost = lws_create_vhost(context, &info);
Test-server-v2.0.c (src\net\libwebsockets\test-apps):		if (!dynamic_vhost_enable && dynamic_vhost) {
Test-server-v2.0.c (src\net\libwebsockets\test-apps):			lwsl_notice("destroying dynamic vhost...\n");
Test-server-v2.0.c (src\net\libwebsockets\test-apps):			lws_vhost_destroy(dynamic_vhost);
Test-server-v2.0.c (src\net\libwebsockets\test-apps):			dynamic_vhost = NULL;
Test-server-v2.0.c (src\net\libwebsockets\test-apps):	dynamic_vhost_enable ^= 1;
Test-server-v2.0.c (src\net\libwebsockets\test-apps):	lwsl_notice("SIGUSR1: dynamic_vhost_enable: %d\n",
Test-server-v2.0.c (src\net\libwebsockets\test-apps):			dynamic_vhost_enable);
Test-server-v2.0.c (src\net\libwebsockets\test-apps):		       uv_timeout_dynamic_vhost_toggle, 0, 0);
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#if defined(TEST_DYNAMIC_VHOST)
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#if defined(TEST_DYNAMIC_VHOST)
Test-server-v2.0.c (src\net\libwebsockets\test-apps):	/* our dynamic vhost is on port + 1 */
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#if defined(TEST_DYNAMIC_VHOST)
Test-server-v2.0.c (src\net\libwebsockets\test-apps):#if defined(TEST_DYNAMIC_VHOST)
Test-server.c (src\net\libwebsockets\test-apps):volatile int force_exit = 0, dynamic_vhost_enable = 0;
Test-server.c (src\net\libwebsockets\test-apps):struct lws_vhost *dynamic_vhost;
Test-server.c (src\net\libwebsockets\test-apps): * plugins, but with static inclusion instead of runtime dynamic loading
Test-server.c (src\net\libwebsockets\test-apps):		dynamic_vhost_enable ^= 1;
Test-server.c (src\net\libwebsockets\test-apps):		lwsl_notice("SIGUSR1: dynamic_vhost_enable: %d\n",
Test-server.c (src\net\libwebsockets\test-apps):				dynamic_vhost_enable);
Test-server.c (src\net\libwebsockets\test-apps):	/* dynamic vhost create / destroy toggle (on port + 1) */
Test-server.c (src\net\libwebsockets\test-apps):	 * For testing dynamic vhost create / destroy later, we use port + 1
Test-server.c (src\net\libwebsockets\test-apps):		if (dynamic_vhost_enable && !dynamic_vhost) {
Test-server.c (src\net\libwebsockets\test-apps):			lwsl_notice("creating dynamic vhost...\n");
Test-server.c (src\net\libwebsockets\test-apps):			dynamic_vhost = lws_create_vhost(context, &info);
Test-server.c (src\net\libwebsockets\test-apps):			if (!dynamic_vhost_enable && dynamic_vhost) {
Test-server.c (src\net\libwebsockets\test-apps):				lwsl_notice("destroying dynamic vhost...\n");
Test-server.c (src\net\libwebsockets\test-apps):				lws_vhost_destroy(dynamic_vhost);
Test-server.c (src\net\libwebsockets\test-apps):				dynamic_vhost = NULL;
Test_etharp.c (src\net\lwip-1.4.1\test\unit\etharp):    /* fill ARP-table with dynamic entries */
Test_etharp.c (src\net\lwip-1.4.1\test\unit\etharp):    /* fill ARP-table with dynamic entries */
Test_etharp.c (src\net\lwip-2.0.3\test\unit\etharp):    /* fill ARP-table with dynamic entries */
Test_etharp.c (src\net\lwip-2.0.3\test\unit\etharp):    /* fill ARP-table with dynamic entries */
Timing.h (include\net\mbedtls-2.16.0\mbedtls): *                 atomic on all platforms, so after the sequence
Timing.h (src\net\mbedtls-2.16.0\include\mbedtls): *                 atomic on all platforms, so after the sequence
Udp.c (src\net\lwip-1.4.1\src\core):   "The Dynamic and/or Private Ports are those from 49152 through 65535" */
Udp.c (src\net\lwip-2.0.3\src\core):   "The Dynamic and/or Private Ports are those from 49152 through 65535" */
Wrap_time.c (src\libc):/* microseconds per second */
Xradio_internal_codec.c (src\driver\chip\codec):static const struct real_val_to_reg_val xradio_maic_mic_pga_gain[] = {
Xradio_internal_codec.c (src\driver\chip\codec):static void xradio_codec_set_main_mic(bool enable)
Xradio_internal_codec.c (src\driver\chip\codec):	XRADIO_CODEC_ALWAYS("Route(cap): main mic %s\n",enable ? "Enable" : "Disable");
Xradio_internal_codec.c (src\driver\chip\codec):	//MIC PGA & ADCL Analog enable/disable
Xradio_internal_codec.c (src\driver\chip\codec):	xradio_codec_reg_update_bits(AC_ADC_ANA_CTRL, 0x1<<MIC_PGA_EN_BIT | 0x1<<ADCL_ANA_EN_BIT, !!enable<<MIC_PGA_EN_BIT | !!enable<<ADCL_ANA_EN_BIT);
Xradio_internal_codec.c (src\driver\chip\codec):static void xradio_codec_set_dmic(bool enable)
Xradio_internal_codec.c (src\driver\chip\codec):	XRADIO_CODEC_ALWAYS("Route(cap): dmic %s\n",enable ? "Enable" : "Disable");
Xradio_internal_codec.c (src\driver\chip\codec):	//xradio DMIC Pin Mux config
Xradio_internal_codec.c (src\driver\chip\codec):	HAL_BoardIoctl(enable ? HAL_BIR_PINMUX_INIT : HAL_BIR_PINMUX_DEINIT, HAL_MKDEV(HAL_DEV_MAJOR_DMIC, 0), 0);
Xradio_internal_codec.c (src\driver\chip\codec):	//DMIC Digital & DMICL/R FIFO enable/disable
Xradio_internal_codec.c (src\driver\chip\codec):	xradio_codec_reg_update_bits(AC_ADC_FIFO_CTRL, 0x1<<DMIC_DIG_EN_BIT | 0x1<<DMICL_FIFO_EN_BIT | 0x1<<DMICR_FIFO_EN_BIT,\
Xradio_internal_codec.c (src\driver\chip\codec):								!!enable<<DMIC_DIG_EN_BIT | !!enable<<DMICL_FIFO_EN_BIT | !!enable<<DMICR_FIFO_EN_BIT);
Xradio_internal_codec.c (src\driver\chip\codec):	//DMIC HPF enable/disable
Xradio_internal_codec.c (src\driver\chip\codec):	xradio_codec_reg_update_bits(AC_ADC_HPF_CTRL, 0x1<<DMIC_HPF_EN_BIT, !!enable<<DMIC_HPF_EN_BIT);
Xradio_internal_codec.c (src\driver\chip\codec):		case AUDIO_IN_DEV_AMIC:
Xradio_internal_codec.c (src\driver\chip\codec):					XRADIO_CODEC_ERR("Invalid main mic volume level: %d!\n",vol_set_value);
Xradio_internal_codec.c (src\driver\chip\codec):				XRADIO_CODEC_ALWAYS("AMIC set volume Level-[%d]\n",vol_set_value);
Xradio_internal_codec.c (src\driver\chip\codec):				for(i=0; i<HAL_ARRAY_SIZE(xradio_maic_mic_pga_gain); i++){
Xradio_internal_codec.c (src\driver\chip\codec):					if(xradio_maic_mic_pga_gain[i].real_val == vol_set_value){
Xradio_internal_codec.c (src\driver\chip\codec):						reg_val = xradio_maic_mic_pga_gain[i].reg_val;
Xradio_internal_codec.c (src\driver\chip\codec):						XRADIO_CODEC_ALWAYS("AMIC set volume Gain-[%d]\n",vol_set_value);
Xradio_internal_codec.c (src\driver\chip\codec):				if(i == HAL_ARRAY_SIZE(xradio_maic_mic_pga_gain)){
Xradio_internal_codec.c (src\driver\chip\codec):					XRADIO_CODEC_ERR("Invalid main mic volume gain: %d!\n",vol_set_value);
Xradio_internal_codec.c (src\driver\chip\codec):			xradio_codec_reg_update_bits(AC_ADC_ANA_CTRL, 0x7<<MIC_PGA_GAIN_BIT, reg_val<<MIC_PGA_GAIN_BIT);
Xradio_internal_codec.c (src\driver\chip\codec):		case AUDIO_IN_DEV_DMIC:
Xradio_internal_codec.c (src\driver\chip\codec):			XRADIO_CODEC_ERR("DMIC don't support set volume\n");
Xradio_internal_codec.c (src\driver\chip\codec):		case AUDIO_IN_DEV_AMIC:
Xradio_internal_codec.c (src\driver\chip\codec):			xradio_codec_set_main_mic(enable);
Xradio_internal_codec.c (src\driver\chip\codec):		case AUDIO_IN_DEV_DMIC:
Xradio_internal_codec.c (src\driver\chip\codec):			xradio_codec_set_dmic(enable);
Xradio_internal_codec.c (src\driver\chip\codec):		//default channel enable order: ADCL->ADCR->DMICL->DMICR
Xradio_internal_codec.c (src\driver\chip\codec):			case AUDIO_IN_DEV_AMIC:
Xradio_internal_codec.c (src\driver\chip\codec):				xradio_codec_set_main_mic(1);
Xradio_internal_codec.c (src\driver\chip\codec):				xradio_codec_reg_update_bits(AC_ADC_FIFO_CTRL, 0x1<<ADC_DMIC_EN_BIT, 0x0<<ADC_DMIC_EN_BIT);				 //ADC_DMIC MUX Select ADC
Xradio_internal_codec.c (src\driver\chip\codec):				xradio_codec_reg_update_bits(AC_ADC_FIFO_CTRL, 0x1<<ADC_DMIC_EN_BIT, 0x0<<ADC_DMIC_EN_BIT);				 //ADC_DMIC MUX Select ADC
Xradio_internal_codec.c (src\driver\chip\codec):			case AUDIO_IN_DEV_DMIC:
Xradio_internal_codec.c (src\driver\chip\codec):				//xradio_codec_set_dmic(1);
Xradio_internal_codec.c (src\driver\chip\codec):				HAL_BoardIoctl(HAL_BIR_PINMUX_INIT, HAL_MKDEV(HAL_DEV_MAJOR_DMIC, 0), 0);
Xradio_internal_codec.c (src\driver\chip\codec):				xradio_codec_reg_update_bits(AC_ADC_FIFO_CTRL, 0x1<<ADC_DMIC_EN_BIT, 0x1<<ADC_DMIC_EN_BIT);				 //ADC_DMIC MUX Select DMIC
Xradio_internal_codec.c (src\driver\chip\codec):				xradio_codec_reg_update_bits(AC_ADC_FIFO_CTRL, 0x1<<ADC_TO_DAC_MUX_SEL_BIT, 0x0<<ADC_TO_DAC_MUX_SEL_BIT);//ADC_TO_DAC MUX Select DMIC Left Channel
Xradio_internal_codec.c (src\driver\chip\codec):		//DAC Mixer && ADC_DMIC MUX && ADC_TO_DAC MUX recover to default status
Xradio_internal_codec.c (src\driver\chip\codec):		xradio_codec_reg_update_bits(AC_ADC_FIFO_CTRL, 0x1<<ADC_DMIC_EN_BIT, 0x0<<ADC_DMIC_EN_BIT);					//ADC_DMIC MUX Select ADC
Xradio_internal_codec.c (src\driver\chip\codec):			case AUDIO_IN_DEV_AMIC:
Xradio_internal_codec.c (src\driver\chip\codec):				xradio_codec_set_main_mic(0);
Xradio_internal_codec.c (src\driver\chip\codec):			case AUDIO_IN_DEV_DMIC:
Xradio_internal_codec.c (src\driver\chip\codec):				//xradio_codec_set_dmic(0);
Xradio_internal_codec.c (src\driver\chip\codec):				HAL_BoardIoctl(HAL_BIR_PINMUX_DEINIT, HAL_MKDEV(HAL_DEV_MAJOR_DMIC, 0), 0);
Xradio_internal_codec.h (src\driver\chip\codec):#define DMIC_DIG_EN_BIT			27
Xradio_internal_codec.h (src\driver\chip\codec):#define ADC_DMIC_EN_BIT			22
Xradio_internal_codec.h (src\driver\chip\codec):#define ADC_DMIC_MONO_EN_BIT	21
Xradio_internal_codec.h (src\driver\chip\codec):#define DMICR_FIFO_EN_BIT		14
Xradio_internal_codec.h (src\driver\chip\codec):#define DMICL_FIFO_EN_BIT		13
Xradio_internal_codec.h (src\driver\chip\codec):#define DMIC_HPF_EN_BIT			1
Xradio_internal_codec.h (src\driver\chip\codec):#define ADCR_IOPMICS_BIT		18
Xradio_internal_codec.h (src\driver\chip\codec):#define MIC_MODE_SEL_BIT		13
Xradio_internal_codec.h (src\driver\chip\codec):#define MIC_PGA_GAIN_BIT		10
Xradio_internal_codec.h (src\driver\chip\codec):#define MIC_PGA_EN_BIT			9
Xradio_internal_codec.h (src\driver\chip\codec):#define ADCL_IOPMICS_BIT		2
Xz.h (include\xz): * Multi-call mode with dynamically allocated dictionary (XZ_DYNALLOC):
YTAwakeDemo.c (project\example\ytasr):	audio_manager_handler(AUDIO_SND_CARD_DEFAULT, AUDIO_MANAGER_SET_VOLUME_LEVEL, AUDIO_IN_DEV_AMIC, 3);
---- Invalid sound card num Matches (20 in 3 files) ----
Audio_manager.c (src\audio\manager):		AUDIO_MANAGER_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_manager.c (src\audio\manager):		AUDIO_MANAGER_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_manager.c (src\audio\manager):		AUDIO_MANAGER_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_manager.c (src\audio\manager):		AUDIO_MANAGER_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_manager.c (src\audio\manager):		AUDIO_MANAGER_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_pcm.c (src\audio\pcm):		AUDIO_PCM_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_pcm.c (src\audio\pcm):		AUDIO_PCM_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_pcm.c (src\audio\pcm):		AUDIO_PCM_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_pcm.c (src\audio\pcm):		AUDIO_PCM_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Audio_pcm.c (src\audio\pcm):		AUDIO_PCM_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		//HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
Hal_snd_card.c (src\driver\chip\codec):		HAL_SND_CARD_ERROR("Invalid sound card num [%d]!\n",(uint8_t)card_num);
---- atcmd_sendTask Matches (3 in 1 files) ----
Serial.c (project\demo\at_demo):void atcmd_sendTask(void *pvParameters);
Serial.c (project\demo\at_demo):		                atcmd_sendTask,
Serial.c (project\demo\at_demo):void atcmd_sendTask(void *pvParameters)
---- __CONFIG_SECURE_BOOT Matches (17 in 6 files) ----
Config.mk:__CONFIG_SECURE_BOOT ?= n
Config.mk:ifeq ($(__CONFIG_SECURE_BOOT), y)
Config.mk:  CONFIG_SYMBOLS += -D__CONFIG_SECURE_BOOT
Localconfig.mk (project\bootloader\gcc):export __CONFIG_SECURE_BOOT := n
Main.c (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Main.c (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Main.c (project\bootloader):#endif /* __CONFIG_SECURE_BOOT */
Main.c (project\bootloader):#if (defined(__CONFIG_SECURE_BOOT) && BL_SB_TEST_LOAD_BOOT_BIN)
Main.c (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Main.c (project\bootloader):#if (defined(__CONFIG_SECURE_BOOT) && BL_SB_TEST_LOAD_BOOT_BIN)
Platform_init.c (project\common\framework):#if ((defined(__CONFIG_XIP)) || (defined(__CONFIG_PSRAM)) || (defined(__CONFIG_SECURE_BOOT)))
Platform_init.c (project\common\framework):#if (defined(__CONFIG_SECURE_BOOT))
Prj_config.h (project\bootloader):#ifdef __CONFIG_SECURE_BOOT
Project.mk (project):ifeq ($(__CONFIG_SECURE_BOOT), y)
Project.mk (project):ifeq ($(__CONFIG_SECURE_BOOT), y)
Project.mk (project):ifeq ($(__CONFIG_SECURE_BOOT), y)
Project.mk (project):endif # __CONFIG_SECURE_BOOT
---- __CONFIG_HOSC_TYPE Matches (9 in 3 files) ----
Board_common.c (project\common\board):#if (__CONFIG_HOSC_TYPE == 24)
Board_common.c (project\common\board):#elif (__CONFIG_HOSC_TYPE == 26)
Board_common.c (project\common\board):#elif (__CONFIG_HOSC_TYPE == 40)
Board_common.c (project\common\board):#elif (__CONFIG_HOSC_TYPE == 52)
Config.mk:# __CONFIG_HOSC_TYPE ?= 24
Config.mk:CONFIG_SYMBOLS += -D__CONFIG_HOSC_TYPE=$(__CONFIG_HOSC_TYPE)
Project.mk (project):BOOT_BIN_NAME := boot_$(__CONFIG_HOSC_TYPE)M.bin
Project.mk (project):WLAN_SDD_NAME := wlan_sdd_$(__CONFIG_HOSC_TYPE)M.bin
---- __CONFIG_YTASR Matches (2 in 2 files) ----
Localconfig.mk (project\example\ytasr\gcc):export __CONFIG_YTASR :=y
Project.mk (project):ifeq ($(__CONFIG_YTASR), y)
---- __CONFIG_HOSC_TYPE Matches (9 in 3 files) ----
Board_common.c (project\common\board):#if (__CONFIG_HOSC_TYPE == 24)
Board_common.c (project\common\board):#elif (__CONFIG_HOSC_TYPE == 26)
Board_common.c (project\common\board):#elif (__CONFIG_HOSC_TYPE == 40)
Board_common.c (project\common\board):#elif (__CONFIG_HOSC_TYPE == 52)
Config.mk:# __CONFIG_HOSC_TYPE ?= 24
Config.mk:CONFIG_SYMBOLS += -D__CONFIG_HOSC_TYPE=$(__CONFIG_HOSC_TYPE)
Project.mk (project):BOOT_BIN_NAME := boot_$(__CONFIG_HOSC_TYPE)M.bin
Project.mk (project):WLAN_SDD_NAME := wlan_sdd_$(__CONFIG_HOSC_TYPE)M.bin
---- __CONFIG_PSRAM Matches (71 in 26 files) ----
Board_common.c (project\common\board):#ifdef __CONFIG_PSRAM
Board_common.c (project\common\board):#ifdef __CONFIG_PSRAM
Board_common.c (project\common\board):#if (defined __CONFIG_PSRAM_CHIP_SQPI)
Board_common.c (project\common\board):#elif (defined __CONFIG_PSRAM_CHIP_OPI32)
Board_common.c (project\common\board):#elif (defined __CONFIG_PSRAM_CHIP_OPI64)
Board_common.c (project\common\board):#ifdef __CONFIG_PSRAM
Board_config.c (project\common\board\xradio_audio):#ifdef __CONFIG_PSRAM
Board_config.c (project\common\board\xradio_evb):#ifdef __CONFIG_PSRAM
Board_config.c (project\common\board\xradio_storybot):#ifdef __CONFIG_PSRAM
Board_config.c (project\common\board\xradio_yt):#ifdef __CONFIG_PSRAM
Board_config.c (project\example\wlan_low_power\board):#ifdef __CONFIG_PSRAM
Cdx_memory.c (project\common\apps\cedarx):#ifdef __CONFIG_PSRAM
Cmd_camera.c (project\common\cmd)://#ifdef __CONFIG_PSRAM
Cmd_camera.c (project\common\cmd)://#ifdef __CONFIG_PSRAM
Cmd_psram.c (project\common\cmd):#ifdef __CONFIG_PSRAM
Config.mk:ifeq ($(__CONFIG_PSRAM), y)
Config.mk:__CONFIG_PSRAM ?= n
Config.mk:ifeq ($(__CONFIG_PSRAM), y)
Config.mk:  __CONFIG_PSRAM_CHIP_OPI32 ?= y
Config.mk:  __CONFIG_PSRAM_CHIP_OPI32 ?= n
Config.mk:__CONFIG_PSRAM_CHIP_OPI64 ?= n
Config.mk:__CONFIG_PSRAM_CHIP_SQPI ?= n
Config.mk:ifeq ($(__CONFIG_PSRAM), y)
Config.mk:  CONFIG_SYMBOLS += -D__CONFIG_PSRAM
Config.mk:ifeq ($(__CONFIG_PSRAM_CHIP_SQPI), y)
Config.mk:  CONFIG_SYMBOLS += -D__CONFIG_PSRAM_CHIP_SQPI
Config.mk:ifeq ($(__CONFIG_PSRAM_CHIP_OPI32), y)
Config.mk:  CONFIG_SYMBOLS += -D__CONFIG_PSRAM_CHIP_OPI32
Config.mk:ifeq ($(__CONFIG_PSRAM_CHIP_OPI64), y)
Config.mk:  CONFIG_SYMBOLS += -D__CONFIG_PSRAM_CHIP_OPI64
Hal_dcache.c (src\driver\chip):#ifdef __CONFIG_PSRAM
Hal_dcache.h (include\driver\chip):#ifdef __CONFIG_PSRAM
Hal_dma.c (src\driver\chip):#if (((__CONFIG_CACHE_POLICY & 0xF) != 0) && (defined __CONFIG_PSRAM))
Hal_psramctrl.c (src\driver\chip\psram):#ifdef __CONFIG_PSRAM
Localconfig.mk (project\example\dma\gcc):export __CONFIG_PSRAM := n
Localconfig.mk (project\example\ytasr\gcc):#export __CONFIG_PSRAM :=n
Localconfig.mk (project\example\ytasr\gcc):#export __CONFIG_PSRAM_CHIP_OPI64 :=n
Platform_init.c (project\common\framework):#ifdef __CONFIG_PSRAM
Platform_init.c (project\common\framework):#if ((defined(__CONFIG_XIP)) || (defined(__CONFIG_PSRAM)) || (defined(__CONFIG_SECURE_BOOT)))
Platform_init.c (project\common\framework):#if (defined(__CONFIG_PSRAM))
Platform_init.c (project\common\framework):#if (defined(__CONFIG_XIP) || defined(__CONFIG_PSRAM))
Platform_init.c (project\common\framework):#if ((defined(__CONFIG_PSRAM)) && ((__CONFIG_CACHE_POLICY & 0xF) != 0))
Project.mk (project):ifeq ($(__CONFIG_PSRAM), y)
Project.mk (project):ifeq ($(__CONFIG_PSRAM), y)
Project.mk (project):ifeq ($(__CONFIG_PSRAM), y)
Project.mk (project):ifeq ($(__CONFIG_PSRAM), y)
Psram.c (project\common\framework):#ifdef __CONFIG_PSRAM
Psram.c (project\common\framework):#if ((defined __CONFIG_PSRAM_CHIP_SQPI) && ((defined LOAD_BY_SBUS_CPU) || (defined LOAD_BY_SBUS_DMA)))
Psram.c (project\common\framework):#if (defined __CONFIG_PSRAM_CHIP_SQPI)
Psram.c (project\common\framework):#elif (defined __CONFIG_PSRAM_CHIP_OPI32)
Psram.c (project\common\framework):#elif (defined __CONFIG_PSRAM_CHIP_OPI64)
Psram.c (project\common\framework):#endif /* __CONFIG_PSRAM */
Psram.h (project\common\framework):#ifdef __CONFIG_PSRAM
Psram.h (project\common\framework):#endif /* __CONFIG_PSRAM */
Psram_core.c (src\driver\chip\psram):#ifdef __CONFIG_PSRAM
Psram_core.c (src\driver\chip\psram):        #if (defined __CONFIG_PSRAM_CHIP_SQPI)
Psram_core.c (src\driver\chip\psram):        #elif (defined __CONFIG_PSRAM_CHIP_OPI32)
Psram_core.c (src\driver\chip\psram):        #elif (defined __CONFIG_PSRAM_CHIP_OPI64)
Psram_core.c (src\driver\chip\psram):#if (defined __CONFIG_PSRAM_CHIP_SQPI)
Psram_core.c (src\driver\chip\psram):#elif (defined __CONFIG_PSRAM_CHIP_OPI32)
Psram_core.c (src\driver\chip\psram):#elif (defined __CONFIG_PSRAM_CHIP_OPI64)
Psram_core.c (src\driver\chip\psram):#endif /* __CONFIG_PSRAM */
Psram_heap_4.c (src\driver\chip\psram):#ifdef __CONFIG_PSRAM
Psram_heap_4.c (src\driver\chip\psram):#endif /* __CONFIG_PSRAM */
Psram_opi32.c (src\driver\chip\psram):#if (defined __CONFIG_PSRAM_CHIP_OPI32)
Psram_opi32.c (src\driver\chip\psram):#endif /* __CONFIG_PSRAM_CHIP_OPI32 */
Psram_opi64.c (src\driver\chip\psram):#if (defined __CONFIG_PSRAM_CHIP_OPI64)
Psram_opi64.c (src\driver\chip\psram):#endif /* __CONFIG_PSRAM_CHIP_OPI64 */
Psram_sqpi.c (src\driver\chip\psram):#if (defined __CONFIG_PSRAM_CHIP_SQPI)
Psram_sqpi.c (src\driver\chip\psram):#endif /* __CONFIG_PSRAM_CHIP_SQPI */
Rom_core.c (src\rom):#ifdef __CONFIG_PSRAM
